{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyValidX","text":"<p>Custom field validation for Python with Pydantic</p> <p>PyValidX is a powerful and flexible validation library built on top of Pydantic that provides a rich set of validators for common use cases while allowing you to create custom validation logic with ease.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83c\udfaf Easy to Use: Simple validation with clear, readable syntax</li> <li>\ud83d\udd27 Flexible: Support for custom validators and conditional validation</li> <li>\ud83d\udcdd Type Safe: Built on Pydantic with full type annotation support</li> <li>\ud83c\udf0d Comprehensive: Wide range of built-in validators for strings, numbers, dates, and more</li> <li>\ud83d\ude80 Performance: Efficient validation with minimal overhead</li> <li>\ud83d\udcd6 Well Documented: Comprehensive documentation with examples</li> </ul>"},{"location":"#quick-example","title":"\ud83d\ude80 Quick Example","text":"<pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required\nfrom pyvalidx.string import is_email, is_strong_password\nfrom pyvalidx.numeric import min_value\n\nclass User(ValidatedModel):\n    name: str = field_validated(is_required())\n    email: str = field_validated(is_required(), is_email())\n    password: str = field_validated(is_required(), is_strong_password())\n    age: int = field_validated(is_required(), min_value(18))\n\n# This will validate automatically\ntry:\n    user = User(\n        name='John Doe',\n        email='john@example.com', \n        password='SecurePass123!',\n        age=25\n    )\n    print('User created successfully!')\nexcept ValidationException as e:\n    print(f'Validation failed: {e.to_dict()}')\n</code></pre>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>Install PyValidX using pip:</p> <pre><code>pip install pyvalidx\n</code></pre> <p>Or with poetry:</p> <pre><code>poetry add pyvalidx\n</code></pre>"},{"location":"#fastapi-integration","title":"\ud83d\udd0c FastAPI Integration","text":"<p>PyValidX works seamlessly with FastAPI for robust API validation:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.responses import JSONResponse\nfrom pyvalidx import ValidatedModel, ValidationException, field_validated\nfrom pyvalidx.core import is_required\nfrom pyvalidx.string import is_email, is_strong_password\n\napp = FastAPI()\n\n# Configure global exception handler\n@app.exception_handler(ValidationException)\nasync def validation_exception_handler(request, exc: ValidationException):\n    return JSONResponse(\n        status_code=400,\n        content={\"error\": \"Validation failed\", \"details\": exc.to_dict()}\n    )\n\n# Define your DTO\nclass CreateUserDto(ValidatedModel):\n    username: str = field_validated(is_required())\n    email: str = field_validated(is_required(), is_email())\n    password: str = field_validated(is_required(), is_strong_password())\n\n# Use it in your endpoint\n@app.post(\"/users\")\nasync def create_user(payload: CreateUserDto):\n    # Validation happens automatically!\n    return {\"message\": \"User created\", \"username\": payload.username}\n</code></pre> <p>Error Response Example: <pre><code>{\n  \"error\": \"Validation failed\",\n  \"details\": {\n    \"email\": [\"Invalid email format\"],\n    \"password\": [\"Password must be strong\"]\n  }\n}\n</code></pre></p>"},{"location":"#core-concepts","title":"\ud83c\udfaf Core Concepts","text":""},{"location":"#validators","title":"Validators","text":"<p>Validators are functions that check if a value meets certain criteria. They return <code>True</code> if valid, <code>False</code> otherwise.</p>"},{"location":"#validatedmodel","title":"ValidatedModel","text":"<p>A Pydantic model that automatically runs custom validators on initialization and provides error handling.</p>"},{"location":"#field_validated","title":"field_validated","text":"<p>A field decorator that attaches validators to model fields.</p>"},{"location":"#validationexception","title":"ValidationException","text":"<p>A custom exception that provides structured error information when validation fails.</p>"},{"location":"#available-validators","title":"\ud83d\udcda Available Validators","text":""},{"location":"#core-validators","title":"Core Validators","text":"<ul> <li><code>is_required()</code> - Ensures field is not None, empty string, or empty list</li> <li><code>min_length()</code> - Minimum string/list length</li> <li><code>max_length()</code> - Maximum string/list length</li> <li><code>same_as()</code> - Field must match another field</li> <li><code>required_if()</code> - Conditional requirement based on another field</li> </ul>"},{"location":"#string-validators","title":"String Validators","text":"<ul> <li><code>is_email()</code> - Valid email format</li> <li><code>is_strong_password()</code> - Strong password requirements</li> <li><code>matches_regex()</code> - Custom regex pattern matching</li> <li><code>no_whitespace()</code> - No spaces allowed</li> <li><code>is_phone()</code> - Colombian phone number format</li> </ul>"},{"location":"#numeric-validators","title":"Numeric Validators","text":"<ul> <li><code>is_positive()</code> - Positive numbers only</li> <li><code>is_integer()</code> - Integer type validation</li> <li><code>is_float()</code> - Float type validation</li> <li><code>min_value()</code> - Minimum numeric value</li> <li><code>max_value()</code> - Maximum numeric value</li> </ul>"},{"location":"#date-validators","title":"Date Validators","text":"<ul> <li><code>is_date()</code> - Valid date format</li> <li><code>is_future_date()</code> - Date must be in the future</li> <li><code>is_past_date()</code> - Date must be in the past</li> <li><code>is_today()</code> - Date must be today</li> </ul>"},{"location":"#type-validators","title":"Type Validators","text":"<ul> <li><code>is_dict()</code> - Dictionary type validation</li> <li><code>is_list()</code> - List type validation</li> <li><code>is_boolean()</code> - Boolean type validation</li> <li><code>is_in()</code> - Value must be in specified choices</li> </ul>"},{"location":"#quick-links","title":"\ud83d\udd17 Quick Links","text":"<ul> <li>Getting Started - Install and set up PyValidX</li> <li>Validators - Explore all available validators</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#author","title":"\ud83d\udc64 Author","text":"<p>Harrison Alonso Arroyave Gaviria - GitHub: @harrison-gaviria - Email: harrisonarroyaveg@gmail.com</p>"},{"location":"advanced/conditional-validation/","title":"Conditional Validation","text":"<p>Conditional validation allows applying validation rules based on the values of other fields or specific context conditions.</p>"},{"location":"advanced/conditional-validation/#basic-required_if","title":"Basic required_if","text":"<p>The <code>required_if</code> validator is the simplest form of conditional validation:</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import required_if, is_required\n\nclass PaymentModel(ValidatedModel):\n    payment_method: str = field_validated(\n        is_required('Payment method is required')\n    )\n\n    # Only required if payment_method is 'credit_card'\n    card_number: str = field_validated(\n        required_if('payment_method', 'credit_card', 'Card number required for credit card payments')\n    )\n\n    # Only required if payment_method is 'bank_transfer'\n    bank_account: str = field_validated(\n        required_if('payment_method', 'bank_transfer', 'Bank account required for transfers')\n    )\n\n# Valid usage - Credit card\npayment1 = PaymentModel(\n    payment_method='credit_card',\n    card_number='1234-5678-9012-3456'\n)\n\n# Valid usage - Bank transfer\npayment2 = PaymentModel(\n    payment_method='bank_transfer',\n    bank_account='123456789'\n)\n\n# Valid usage - Cash (no additional fields required)\npayment3 = PaymentModel(payment_method='cash')\n</code></pre>"},{"location":"advanced/conditional-validation/#custom-conditional-validation","title":"Custom Conditional Validation","text":""},{"location":"advanced/conditional-validation/#multiple-conditions","title":"Multiple Conditions","text":"<pre><code>from pyvalidx.core import custom\n\ndef required_if_multiple(conditions: dict, message: str):\n    '''Validator that requires field if multiple conditions are met'''\n    def validator(value, context=None):\n        if context is None:\n            return True\n\n        # Check if all conditions are met\n        all_conditions_met = all(\n            context.get(field) == expected_value\n            for field, expected_value in conditions.items()\n        )\n\n        if all_conditions_met:\n            return value is not None and str(value).strip() != ''\n        return True\n\n    validator.__message__ = message\n    return validator\n\nclass ShippingModel(ValidatedModel):\n    country: str = field_validated(is_required())\n    shipping_method: str = field_validated(is_required())\n\n    # Only required if country='US' AND shipping_method='express'\n    signature_required: bool = field_validated(\n        custom(\n            required_if_multiple(\n                {'country': 'US', 'shipping_method': 'express'},\n                'Signature is required for express shipping in US'\n            )\n        )\n    )\n\n# Usage\nshipping = ShippingModel(\n    country='US',\n    shipping_method='express',\n    signature_required=True\n)\n</code></pre>"},{"location":"advanced/conditional-validation/#conditional-format-validation","title":"Conditional Format Validation","text":"<pre><code>def conditional_format_validator(condition_field: str, condition_value: str, pattern: str, message: str) -&gt; Callable[[Any, Optional[Dict[str, Any]]], bool]:\n    '''\n    Validates format only when condition is met\n\n    Args:\n        condition_field (str): Field to check for condition\n        condition_value (str): Value that makes format validation active\n        pattern (str): Regex pattern to validate against\n        message (str): Error message if validation fails\n\n    Returns:\n        Callable[[Any, Optional[Dict[str, Any]]], bool]: Validator function\n    '''\n    def validator(value, context=None):\n        if context is None or value is None:\n            return True\n\n        if context.get(condition_field) == condition_value:\n            import re\n            return bool(re.match(pattern, str(value)))\n        return True\n\n    validator.__message__ = message\n    return validator\n\nclass ContactModel(ValidatedModel):\n    contact_type: str = field_validated(is_required())\n    contact_value: str = field_validated(is_required())\n\n    # Validate email format only if contact_type is \"email\"\n    formatted_contact: str = field_validated(\n        custom(\n            conditional_format_validator(\n                'contact_type',\n                'email',\n                r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$',\n                'Invalid email format'\n            )\n        )\n    )\n\n# Usage\ncontact = ContactModel(\n    contact_type='email',\n    contact_value='user@example.com',\n    formatted_contact='user@example.com'\n)\n</code></pre>"},{"location":"advanced/conditional-validation/#conditional-validation-with-business-logic","title":"Conditional Validation with Business Logic","text":""},{"location":"advanced/conditional-validation/#discount-system","title":"Discount System","text":"<pre><code>def discount_validation(value, context=None) -&gt; bool:\n    '''\n    Validates discount based on customer type and order amount\n\n    Args:\n        value (Any): Discount value to validate\n        context (Dict[str, Any], optional): Context containing customer_type and order_amount\n\n    Returns:\n        bool: True if discount is valid, False otherwise\n    '''\n    if value is None or context is None:\n        return True\n\n    customer_type = context.get('customer_type')\n    order_amount = context.get('order_amount', 0)\n    discount = float(value)\n\n    # Business rules for discounts\n    if customer_type == 'regular':\n        max_discount = 10 if order_amount &gt;= 100 else 5\n    elif customer_type == 'premium':\n        max_discount = 20 if order_amount &gt;= 100 else 15\n    elif customer_type == 'vip':\n        max_discount = 30\n    elif customer_type == 'employee':\n        max_discount = 50\n    else:\n        return False\n\n    return 0 &lt;= discount &lt;= max_discount\n\ndiscount_validation.__message__ = 'Invalid discount for customer type or order amount'\n\nclass OrderModel(ValidatedModel):\n    customer_type: str = field_validated(\n        is_required(),\n        is_in(['regular', 'premium', 'vip', 'employee'])\n    )\n\n    order_amount: float = field_validated(\n        is_required(),\n        is_positive()\n    )\n\n    discount_percentage: float = field_validated(\n        custom(discount_validation, 'Invalid discount for customer type or order amount')\n    )\n\n# Valid usage\norder = OrderModel(\n    customer_type='premium',\n    order_amount=150.0,\n    discount_percentage=18.0\n)\n\n# Invalid usage - discount too high for regular customer\ntry:\n    invalid_order = OrderModel(\n        customer_type='regular',\n        order_amount=50.0,\n        discount_percentage=25.0\n    )\nexcept ValidationException as e:\n    print(e.validations)\n</code></pre>"},{"location":"advanced/conditional-validation/#advanced-conditional-validation-patterns","title":"Advanced Conditional Validation Patterns","text":""},{"location":"advanced/conditional-validation/#cascade-validation","title":"Cascade Validation","text":"<pre><code>def conditional_requirement(condition_func: Callable[[Dict[str, Any]], bool], message: str) -&gt; Callable[[Any, Optional[Dict[str, Any]]], bool]:\n    '''\n    Generic conditional requirement validator\n\n    Args:\n        condition_func (Callable[[Dict[str, Any]], bool]): Function that takes context and returns True if condition is met\n        message (str): Error message if validation fails\n\n    Returns:\n        Callable[[Any, Optional[Dict[str, Any]]], bool]: Validator function\n    '''\n    def validator(value, context=None):\n        if condition_func(context):\n            return value is not None and str(value).strip() != ''\n        return True\n\n    validator.__message__ = message\n    return validator\n\nclass EmployeeModel(ValidatedModel):\n    employee_type: str = field_validated(\n        is_required(),\n        is_in(['full_time', 'part_time', 'contractor', 'intern'])\n    )\n\n    # Only for full-time and part-time employees\n    benefits_eligible: bool = field_validated(\n        custom(\n            required_if_multiple(\n                {'employee_type': 'full_time'},\n                'Benefits eligibility required for full-time employees'\n            )\n        )\n    )\n\n    # Only if eligible for benefits\n    health_plan: str = field_validated(\n        custom(\n            conditional_requirement(\n                lambda ctx: ctx.get('benefits_eligible') == True,\n                'Health plan selection required for benefits-eligible employees'\n            )\n        )\n    )\n</code></pre>"},{"location":"advanced/conditional-validation/#at-least-one-required","title":"At Least One Required","text":"<pre><code>def at_least_one_required(fields: list, message: str) -&gt; Callable[[Any, Optional[Dict[str, Any]]], bool]:\n    '''\n    Validates that at least one of the specified fields has a value\n\n    Args:\n        fields (list): List of field names to check\n        message (str): Error message if validation fails\n\n    Returns:\n        Callable[[Any, Optional[Dict[str, Any]]], bool]: Validator function\n    '''\n    def validator(value, context=None):\n        if context is None:\n            return True\n\n        # Check if at least one field has a value\n        has_value = any(\n            context.get(field) is not None and str(context.get(field)).strip() != ''\n            for field in fields\n        )\n\n        return has_value\n\n    validator.__message__ = message\n    return validator\n\nclass ContactFormModel(ValidatedModel):\n    name: str = field_validated(is_required())\n\n    # At least one of these must be present\n    email: str = field_validated(\n        custom(\n            at_least_one_required(['email', 'phone'], 'Either email or phone is required')\n        ),\n        is_email()\n    )\n\n    phone: str = field_validated(\n        custom(\n            at_least_one_required(['email', 'phone'], 'Either email or phone is required')\n        ),\n        is_phone()\n    )\n\n# Valid usage - email only\ncontact1 = ContactFormModel(\n    name='John Doe',\n    email='john@example.com'\n)\n\n# Valid usage - phone only\ncontact2 = ContactFormModel(\n    name='Jane Doe',\n    phone='3001234567'\n)\n\n# Valid usage - both\ncontact3 = ContactFormModel(\n    name='Bob Smith',\n    email='bob@example.com',\n    phone='3009876543'\n)\n</code></pre>"},{"location":"advanced/conditional-validation/#debug-and-development-tools","title":"Debug and Development Tools","text":"<pre><code>def debug_conditional_validator(validator_func: Callable[[Any, Optional[Dict[str, Any]]], bool], debug_name: str) -&gt; Callable[[Any, Optional[Dict[str, Any]]], bool]:\n    '''\n    Wrapper that adds debug information to conditional validators\n\n    Args:\n        validator_func (Callable[[Any, Optional[Dict[str, Any]]], bool]): Validator function to wrap\n        debug_name (str): Name for debugging purposes\n\n    Returns:\n        Callable[[Any, Optional[Dict[str, Any]]], bool]: Wrapped validator function\n    '''\n    def wrapper(value, context=None):\n        import time\n        start_time = time.time()\n\n        try:\n            result = validator_func(value, context)\n            end_time = time.time()\n\n            if hasattr(wrapper, '__debug_mode__') and wrapper.__debug_mode__:\n                print(f'[DEBUG] {debug_name}: {result} (took {(end_time - start_time)*1000:.2f}ms)')\n\n            return result\n        except Exception as e:\n            end_time = time.time()\n            debug_info = {\n                'validator_name': debug_name,\n                'validation_time_ms': round((end_time - start_time) * 1000, 2),\n                'exception': str(e),\n                'input_value': str(value)[:100],\n                'context': str(context)[:200] if context else None\n            }\n            wrapper.__debug_info__ = debug_info\n            return False\n\n    wrapper.__message__ = getattr(validator_func, '__message__', 'Validation failed')\n    return wrapper\n\n# Usage in development\nclass DebugModel(ValidatedModel):\n    field1: str = field_validated(is_required())\n    field2: str = field_validated(\n        custom(\n            debug_conditional_validator(\n                required_if('field1', 'special_value'),\n                'required_if_debug'\n            )\n        )\n    )\n</code></pre>"},{"location":"advanced/conditional-validation/#systematic-testing","title":"Systematic Testing","text":"<pre><code>import pytest\n\ndef test_conditional_validation() -&gt; None:\n    '''\n    Comprehensive test for conditional validation\n\n    1. Condition not met, field optional\n    2. Condition met, required field present\n    3. Condition met, required field missing\n    '''\n\n    # Case 1: Condition not met, field optional\n    model1 = PaymentModel(payment_method='cash')\n    assert model1.payment_method == 'cash'\n\n    # Case 2: Condition met, required field present\n    model2 = PaymentModel(\n        payment_method='credit_card',\n        card_number='1234-5678-9012-3456'\n    )\n    assert model2.card_number is not None\n\n    # Case 3: Condition met, required field missing\n    with pytest.raises(ValidationException) as exc_info:\n        PaymentModel(payment_method='credit_card')\n\n    assert 'card_number' in exc_info.value.validations\n\n# Run: pytest test_conditional.py -v\n</code></pre> <p>Conditional validation is a powerful tool that allows creating complex and flexible business rules, adapting to different scenarios based on data context.</p>"},{"location":"advanced/custom-validators/","title":"Custom Validators","text":"<p>PyValidX allows creating custom validators for specific use cases that are not covered by predefined validators.</p>"},{"location":"advanced/custom-validators/#creating-custom-validators","title":"Creating Custom Validators","text":""},{"location":"advanced/custom-validators/#basic-validation-function","title":"Basic Validation Function","text":"<p>A custom validator is a function that: - Receives two parameters: <code>value</code> and <code>context</code> (optional) - Returns <code>True</code> if validation is successful, <code>False</code> if it fails - Has a <code>__message__</code> attribute with the error message</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import custom\n\ndef is_even(value, context=None) -&gt; bool:\n    '''\n    Validates that the number is even\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n    try:\n        return int(value) % 2 == 0\n    except (ValueError, TypeError):\n        return False\n\n# Add error message\nis_even.__message__ = 'Number must be even'\n\nclass NumberModel(ValidatedModel):\n    even_number: int = field_validated(\n        custom(is_even, 'Number must be even')\n    )\n\n# Usage\nvalid_model = NumberModel(even_number=4)  # Valid\n# invalid_model = NumberModel(even_number=3)  # Raises ValidationException\n</code></pre>"},{"location":"advanced/custom-validators/#validador-como-funcion-factory","title":"Validador como Funci\u00f3n Factory","text":"<p>Para validadores m\u00e1s flexibles, crea una funci\u00f3n que retorne el validador:</p> <pre><code>def min_words(word_count: int, message: str = None) -&gt; Callable[[Any, Optional[Dict[str, Any]]], bool]:\n    '''\n    Factory para validar cantidad m\u00ednima de palabras\n\n    Args:\n        word_count (int): Minimum number of words\n        message (str, optional): Error message if validation fails\n\n    Returns:\n        Callable[[Any, Optional[Dict[str, Any]]], bool]: Validator function\n    '''\n    message = message or f'Must contain at least {word_count} words'\n\n    def validator(value, context=None):\n        if value is None:\n            return True\n        word_list = str(value).strip().split()\n        return len(word_list) &gt;= word_count\n\n    validator.__message__ = message\n    return validator\n\nclass ArticleModel(ValidatedModel):\n    title: str = field_validated(min_words(2, 'Title must have at least 2 words'))\n    content: str = field_validated(min_words(10, 'Content must have at least 10 words'))\n\n# Uso\narticle = ArticleModel(\n    title='Python Validation Guide',\n    content='This is a comprehensive guide about creating custom validators in Python...'\n)\n</code></pre>"},{"location":"advanced/custom-validators/#contextual-validators","title":"Contextual Validators","text":"<p>Validators can access other model fields through the <code>context</code> parameter:</p> <pre><code>def password_not_contains_username(value, context=None) -&gt; bool:\n    '''\n    Validates that password does not contain username\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None or context is None:\n        return True\n\n    username = context.get('username', '').lower()\n    password = str(value).lower()\n\n    return username not in password\n\nclass UserRegistrationModel(ValidatedModel):\n    username: str = field_validated(is_required())\n    password: str = field_validated(\n        is_required(),\n        custom(password_not_contains_username, 'Password cannot contain username')\n    )\n\n# Valid usage\nuser = UserRegistrationModel(\n    username='johndoe',\n    password='SecurePass123!'\n)\n\n# Invalid usage\ntry:\n    invalid_user = UserRegistrationModel(\n        username='johndoe',\n        password='johndoe123'\n    )\nexcept ValidationException as e:\n    print(e.validations)  # {'password': 'Password cannot contain username'}\n</code></pre>"},{"location":"advanced/custom-validators/#complex-validation-examples","title":"Complex Validation Examples","text":""},{"location":"advanced/custom-validators/#credit-card-and-isbn-validators","title":"Credit Card and ISBN Validators","text":"<pre><code>def is_credit_card(value, context=None) -&gt; bool:\n    '''\n    Validates credit card number using Luhn algorithm\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n\n    # Remove spaces and hyphens\n    card_number = str(value).replace(' ', '').replace('-', '')\n\n    # Check if all digits\n    if not card_number.isdigit():\n        return False\n\n    # Luhn algorithm\n    def luhn_checksum(card_num):\n        def digits_of(n):\n            return [int(d) for d in str(n)]\n\n        digits = digits_of(card_num)\n        odd_digits = digits[-1::-2]\n        even_digits = digits[-2::-2]\n        checksum = sum(odd_digits)\n        for d in even_digits:\n            checksum += sum(digits_of(d*2))\n        return checksum % 10\n\n    return luhn_checksum(card_number) == 0\n\ndef is_isbn(value, context=None) -&gt; bool:\n    '''\n    Validates ISBN-10 or ISBN-13\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n\n    isbn = str(value).replace('-', '').replace(' ', '')\n\n    if len(isbn) == 10:\n        return _validate_isbn10(isbn)\n    elif len(isbn) == 13:\n        return _validate_isbn13(isbn)\n    else:\n        return False\n\ndef _validate_isbn10(isbn: str) -&gt; bool:\n    '''\n    Validates ISBN-10\n\n    Args:\n        isbn (str): ISBN-10 number\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if not (isbn[:-1].isdigit() and (isbn[-1].isdigit() or isbn[-1].upper() == 'X')):\n        return False\n\n    total = 0\n    for i, digit in enumerate(isbn[:-1]):\n        total += int(digit) * (10 - i)\n\n    check_digit = isbn[-1]\n    if check_digit.upper() == 'X':\n        total += 10\n    else:\n        total += int(check_digit)\n\n    return total % 11 == 0\n\ndef _validate_isbn13(isbn: str) -&gt; bool:\n    \"\"\"Validates ISBN-13\"\"\"\n    if not isbn.isdigit():\n        return False\n\n    total = 0\n    for i, digit in enumerate(isbn[:-1]):\n        multiplier = 1 if i % 2 == 0 else 3\n        total += int(digit) * multiplier\n\n    check_digit = (10 - (total % 10)) % 10\n    return check_digit == int(isbn[-1])\n\n# Usage of custom validators\nclass PaymentModel(ValidatedModel):\n    card_number: str = field_validated(\n        is_required(),\n        custom(is_credit_card, 'Invalid credit card number')\n    )\n\nclass BookModel(ValidatedModel):\n    title: str = field_validated(is_required())\n    isbn: str = field_validated(\n        custom(is_isbn, 'Invalid ISBN format')\n    )\n</code></pre>"},{"location":"advanced/custom-validators/#validators-with-external-dependencies","title":"Validators with External Dependencies","text":""},{"location":"advanced/custom-validators/#database-validation","title":"Database Validation","text":"<pre><code>def username_not_exists(value, context=None) -&gt; bool:\n    '''\n    Validates that username does not exist in database\n\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n\n    # Database query simulation\n    existing_usernames = ['admin', 'root', 'test', 'demo']  # In practice, this would come from DB\n\n    return str(value).lower() not in existing_usernames\n\nclass NewUserModel(ValidatedModel):\n    username: str = field_validated(\n        is_required(),\n        min_length(3),\n        custom(username_not_exists, 'Username already exists')\n    )\n    email: str = field_validated(is_required(), is_email())\n</code></pre>"},{"location":"advanced/custom-validators/#external-api-validation","title":"External API Validation","text":"<pre><code>def is_valid_country_code(value, context=None) -&gt; bool:\n    '''\n    Validates country code using a predefined list\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n\n    # ISO 3166-1 alpha-2 codes list (simulated)\n    valid_codes = {\n        'US', 'CA', 'GB', 'FR', 'DE', 'IT', 'ES', 'BR', 'AR', 'CO',\n        'MX', 'JP', 'CN', 'IN', 'AU', 'NZ', 'ZA', 'EG', 'NG', 'KE'\n    }\n\n    return str(value).upper() in valid_codes\n\nclass InternationalOrderModel(ValidatedModel):\n    customer_name: str = field_validated(is_required())\n    country_code: str = field_validated(\n        is_required(),\n        custom(is_valid_country_code, 'Invalid country code')\n    )\n</code></pre>"},{"location":"advanced/custom-validators/#validators-with-advanced-configuration","title":"Validators with Advanced Configuration","text":""},{"location":"advanced/custom-validators/#configurable-file-validator","title":"Configurable File Validator","text":"<pre><code>def file_extension_validator(allowed_extensions: list) -&gt; Callable[[Any, Optional[Dict[str, Any]]], bool]:\n    '''\n    Creates a validator for file extensions\n\n    Args:\n        allowed_extensions (list): List of allowed file extensions\n\n    Returns:\n        Callable[[Any, Optional[Dict[str, Any]]], bool]: Validator function\n    '''\n    def validator(value, context=None):\n        if value is None:\n            return True\n\n        file_path = str(value)\n        if '.' not in file_path:\n            return False\n\n        extension = file_path.split('.')[-1].lower()\n        return extension in [ext.lower() for ext in allowed_extensions]\n\n    validator.__message__ = f\"File must have one of these extensions: {', '.join(allowed_extensions)}\"\n    return validator\n\nclass DocumentModel(ValidatedModel):\n    document_name: str = field_validated(is_required())\n    file_path: str = field_validated(\n        is_required(),\n        custom(\n            file_extension_validator(['pdf', 'doc', 'docx', 'txt']),\n            'Document must be PDF, DOC, DOCX, or TXT'\n        )\n    )\n\n# Usage\ndocument = DocumentModel(\n    document_name='User Manual',\n    file_path='manual.pdf'\n)\n</code></pre>"},{"location":"advanced/custom-validators/#best-practices","title":"Best Practices","text":""},{"location":"advanced/custom-validators/#1-error-handling","title":"1. Error Handling","text":"<pre><code>def safe_validator(validation_func) -&gt; Callable[[Any, Optional[Dict[str, Any]]], bool]:\n    '''\n    Decorator to handle errors in validators\n\n    Args:\n        validation_func (Callable[[Any, Optional[Dict[str, Any]]], bool]): Validator function\n\n    Returns:\n        Callable[[Any, Optional[Dict[str, Any]]], bool]: Wrapped validator function\n    '''\n    def wrapper(value, context=None):\n        try:\n            return validation_func(value, context)\n        except Exception:\n            return False\n    return wrapper\n\n@safe_validator\ndef complex_validation(value, context=None):\n    # Validation code that might throw exceptions\n    result = some_complex_operation(value)\n    return result.is_valid()\n</code></pre>"},{"location":"advanced/custom-validators/#2-composable-validators","title":"2. Composable Validators","text":"<pre><code>def compose_validators(*validators) -&gt; Callable[[Any, Optional[Dict[str, Any]]], bool]:\n    '''\n    Combines multiple validators into one\n\n    Args:\n        *validators (Callable[[Any, Optional[Dict[str, Any]]], bool]): Validator functions\n\n    Returns:\n        Callable[[Any, Optional[Dict[str, Any]]], bool]: Composed validator function\n    '''\n    def composed_validator(value, context=None):\n        return all(validator(value, context) for validator in validators)\n\n    return composed_validator\n\n# Usage\ndef is_valid_product_code(value, context=None):\n    # Specific product code validations\n    return True\n\ndef is_unique_product_code(value, context=None):\n    # Check uniqueness in database\n    return True\n\nclass ProductModel(ValidatedModel):\n    product_code: str = field_validated(\n        custom(\n            compose_validators(is_valid_product_code, is_unique_product_code),\n            'Invalid or duplicate product code'\n        )\n    )\n</code></pre>"},{"location":"advanced/custom-validators/#3-testing-validators","title":"3. Testing Validators","text":"<pre><code>import pytest\n\ndef test_custom_validator():\n    def is_palindrome(value, context=None):\n        if value is None:\n            return True\n        clean_value = str(value).replace(' ', '').lower()\n        return clean_value == clean_value[::-1]\n\n    # Tests\n    assert is_palindrome('racecar') == True\n    assert is_palindrome('race a car') == False\n    assert is_palindrome('A man a plan a canal Panama') == False\n    assert is_palindrome(None) == True\n\ndef test_validator_with_model():\n    class TestModel(ValidatedModel):\n        palindrome_text: str = field_validated(\n            custom(is_palindrome, 'Text must be a palindrome')\n        )\n\n    # Valid case\n    model = TestModel(palindrome_text='racecar')\n    assert model.palindrome_text == 'racecar'\n\n    # Invalid case\n    with pytest.raises(ValidationException):\n        TestModel(palindrome_text='not a palindrome')\n\n# Run: pytest test_custom_validators.py -v\n</code></pre>"},{"location":"advanced/custom-validators/#4-performance-optimization","title":"4. Performance Optimization","text":"<pre><code>from functools import lru_cache\n\n@lru_cache(maxsize=1000)\ndef expensive_validation(value) -&gt; bool:\n    '''\n    Cached expensive validation\n\n    Args:\n        value (Any): Value to validate\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    # Expensive operation here\n    import time\n    time.sleep(0.1)  # Simulate expensive operation\n    return len(str(value)) &gt; 5\n\nclass OptimizedModel(ValidatedModel):\n    data: str = field_validated(\n        custom(expensive_validation, 'Data validation failed')\n    )\n</code></pre> <p>Custom validators provide the flexibility to implement any validation logic specific to your business requirements while maintaining consistency with PyValidX's validation framework.</p>"},{"location":"advanced/error-handling/","title":"Error Handling","text":"<p>PyValidX provides a robust error handling system through the <code>ValidationException</code> class, which allows capturing, processing, and responding to validation errors in a structured way.</p>"},{"location":"advanced/error-handling/#basic-validationexception","title":"Basic ValidationException","text":""},{"location":"advanced/error-handling/#error-structure","title":"Error Structure","text":"<pre><code>from pyvalidx import ValidatedModel, field_validated, ValidationException\nfrom pyvalidx.core import is_required, min_length\nfrom pyvalidx.string import is_email\n\nclass UserModel(ValidatedModel):\n    name: str = field_validated(\n        is_required('Name is required'),\n        min_length(2, 'Name must be at least 2 characters')\n    )\n    email: str = field_validated(\n        is_required('Email is required'),\n        is_email('Invalid email format')\n    )\n\n# Capture and examine errors\ntry:\n    user = UserModel(name='A', email='invalid-email')\nexcept ValidationException as e:\n    print('Status Code:', e.status_code)  # 400\n    print('Validations:', e.validations)\n    # {'name': 'Name must be at least 2 characters', 'email': 'Invalid email format'}\n\n    # Get as dictionary\n    error_dict = e.to_dict()\n    print('Error Dict:', error_dict)\n\n    # Get as JSON\n    error_json = e.to_json()\n    print('Error JSON:', error_json)\n</code></pre>"},{"location":"advanced/error-handling/#multiple-errors-per-field","title":"Multiple Errors per Field","text":"<pre><code>class PasswordModel(ValidatedModel):\n    password: str = field_validated(\n        is_required('Password is required'),\n        min_length(8, 'Password must be at least 8 characters'),\n        is_strong_password('Password must contain uppercase, lowercase, numbers and symbols')\n    )\n\ntry:\n    # Password that fails multiple validations\n    pwd_model = PasswordModel(password='123')\nexcept ValidationException as e:\n    print(e.validations)\n    # {'password': 'Password must be at least 8 characters'}\n    # Note: Only the first failing error is reported\n</code></pre>"},{"location":"advanced/error-handling/#custom-error-handling","title":"Custom Error Handling","text":""},{"location":"advanced/error-handling/#custom-status-codes","title":"Custom Status Codes","text":"<pre><code>class ValidationException(Exception):\n    def __init__(self, validations, status_code=400):\n        # Default status_code is 400, but can be customized\n        pass\n\n# To create errors with specific codes\ndef validate_admin_user(data):\n    try:\n        return AdminUserModel(**data)\n    except ValidationException as e:\n        # Re-raise with 403 code for authorization errors\n        if 'admin_key' in e.validations:\n            raise ValidationException(e.validations, status_code=403)\n        raise  # Re-raise with original code\n</code></pre>"},{"location":"advanced/error-handling/#error-handling-wrapper","title":"Error Handling Wrapper","text":"<pre><code>from typing import Dict, Any, Tuple, Optional\nimport json\n\nclass ValidationErrorHandler:\n    '''\n    Centralized validation error handler\n    '''\n\n    @staticmethod\n    def handle_validation_error(e: ValidationException) -&gt; Dict[str, Any]:\n        '''\n        Converts ValidationException to standard response format\n\n        Args:\n            e (ValidationException): ValidationException to handle\n\n        Returns:\n            Dict[str, Any]: Standard response format\n        '''\n        return {\n            'success': False,\n            'status_code': e.status_code,\n            'message': 'Validation failed',\n            'errors': e.validations,\n            'error_count': len(e.validations)\n        }\n\n    @staticmethod\n    def safe_validate(model_class, data: Dict[str, Any]) -&gt; Tuple[Optional[Any], Optional[Dict[str, Any]]]:\n        '''\n        Safe validation that returns tuple (model, error)\n\n        Args:\n            model_class (type): Model class to validate\n            data (Dict[str, Any]): Data to validate\n\n        Returns:\n            Tuple[Optional[Any], Optional[Dict[str, Any]]]: Tuple of (model, error)\n        '''\n        try:\n            model = model_class(**data)\n            return model, None\n        except ValidationException as e:\n            return None, ValidationErrorHandler.handle_validation_error(e)\n</code></pre>"},{"location":"advanced/error-handling/#contextual-errors-and-debugging","title":"Contextual Errors and Debugging","text":""},{"location":"advanced/error-handling/#debug-information-in-errors","title":"Debug Information in Errors","text":"<pre><code>class DebugValidationException(ValidationException):\n    '''\n    Extended ValidationException with debug information\n    '''\n\n    def __init__(self, validations, status_code=400, debug_info=None):\n        super().__init__(validations, status_code)\n        self.debug_info = debug_info or {}\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        '''\n        Converts exception to dictionary including debug info\n\n        Returns:\n            Dict[str, Any]: Dictionary representation of the exception including debug info\n        '''\n        result = super().to_dict()\n        if self.debug_info:\n            result['debug_info'] = self.debug_info\n        return result\n</code></pre>"},{"location":"advanced/error-handling/#validation-error-logging","title":"Validation Error Logging","text":"<pre><code>import logging\nfrom datetime import datetime\n\nclass ValidationLogger:\n    '''\n    Logger for validation errors\n    '''\n\n    def __init__(self):\n        self.logger = logging.getLogger('pyvalidx.validation')\n\n    def log_validation_error(self, model_name: str, errors: dict, context: dict = None):\n        '''\n        Log validation errors with context\n\n        Args:\n            model_name (str): Name of the model\n            errors (dict): Validation errors\n            context (dict, optional): Additional context for logging\n        '''\n        log_entry = {\n            'timestamp': datetime.now().isoformat(),\n            'model': model_name,\n            'errors': errors,\n            'context': context or {}\n        }\n        self.logger.error(f'Validation failed: {log_entry}')\n</code></pre>"},{"location":"advanced/error-handling/#error-handling-in-web-applications","title":"Error Handling in Web Applications","text":""},{"location":"advanced/error-handling/#fastapi-integration","title":"FastAPI Integration","text":"<pre><code>from fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\nimport uvicorn\n\napp = FastAPI()\n\n@app.exception_handler(ValidationException)\nasync def validation_exception_handler(request, exc: ValidationException) -&gt; JSONResponse:\n    '''\n    Global handler for ValidationException in FastAPI\n\n    Args:\n        request (Request): FastAPI request object\n        exc (ValidationException): ValidationException to handle\n\n    Returns:\n        JSONResponse: JSON response with error details\n    '''\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            'message': 'Validation failed',\n            'errors': exc.validations,\n            'status_code': exc.status_code\n        }\n    )\n\n@app.post('/users/')\nasync def create_user(user_data: dict):\n    # ValidationException will be caught automatically\n    user = UserModel(**user_data)\n    return {'message': 'User created', 'user': user.model_dump()}\n\n# Usage:\n# POST /users/ with invalid data will automatically return 400 error\n</code></pre>"},{"location":"advanced/error-handling/#flask-integration","title":"Flask Integration","text":"<pre><code>from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.errorhandler(ValidationException)\ndef handle_validation_error(e) -&gt; tuple[dict, int]:\n    '''\n    Global handler for ValidationException in Flask\n\n    Args:\n        e (ValidationException): ValidationException to handle\n\n    Returns:\n        tuple: Tuple of (response, status_code)\n    '''\n    return jsonify(e.to_dict()), e.status_code\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    user_data = request.get_json()\n\n    # ValidationException will be caught automatically\n    user = UserModel(**user_data)\n    return jsonify({'message': 'User created', 'user': user.model_dump()})\n\n# Usage:\n# POST /users with invalid data will automatically return 400 error\n</code></pre>"},{"location":"advanced/error-handling/#advanced-error-handling-patterns","title":"Advanced Error Handling Patterns","text":""},{"location":"advanced/error-handling/#error-accumulation-from-multiple-models","title":"Error Accumulation from Multiple Models","text":"<pre><code>class BatchValidationResult:\n    '''\n    Result container for batch validation\n    '''\n\n    def __init__(self):\n        self.valid_models = []\n        self.invalid_models = []\n        self.errors = {}\n\n    @property\n    def valid_count(self) -&gt; int:\n        return len(self.valid_models)\n\n    @property\n    def invalid_count(self) -&gt; int:\n        return len(self.invalid_models)\n\ndef batch_validate(model_class, data_list: list) -&gt; BatchValidationResult:\n    '''\n    Validate multiple instances and collect all errors\n\n    Args:\n        model_class (type): Model class to validate\n        data_list (list): List of data to validate\n\n    Returns:\n        BatchValidationResult: Result container with validation results\n    '''\n    result = BatchValidationResult()\n\n    for i, data in enumerate(data_list):\n        try:\n            model = model_class(**data)\n            result.valid_models.append(model)\n        except ValidationException as e:\n            result.invalid_models.append(data)\n            result.errors[f\"item_{i}\"] = e.validations\n\n    return result\n\n# Usage\nusers_data = [\n    {'name': 'John', 'email': 'john@example.com'},\n    {'name': 'A', 'email': 'invalid-email'},\n    {'name': 'Jane', 'email': 'jane@example.com'}\n]\n\nbatch_result = batch_validate(UserModel, users_data)\nprint(f'Valid: {batch_result.valid_count}, Invalid: {batch_result.invalid_count}')\n</code></pre>"},{"location":"advanced/error-handling/#retry-with-backoff-for-external-validations","title":"Retry with Backoff for External Validations","text":"<pre><code>import time\nimport random\nfrom functools import wraps\n\ndef retry_validation(max_retries=3, backoff_factor=1.0) -&gt; Callable[[Any, Optional[Dict[str, Any]]], bool]:\n    '''\n    Decorator for retrying validations with exponential backoff\n\n    Args:\n        max_retries (int, optional): Maximum number of retries. Defaults to 3.\n        backoff_factor (float, optional): Backoff factor for exponential backoff. Defaults to 1.0.\n\n    Returns:\n        Callable: Decorated validator function\n    '''\n    def decorator(validator_func):\n        @wraps(validator_func)\n        def wrapper(value, context=None):\n            last_exception = None\n\n            for attempt in range(max_retries + 1):\n                try:\n                    return validator_func(value, context)\n                except Exception as e:\n                    last_exception = e\n                    if attempt &lt; max_retries:\n                        delay = backoff_factor * (2 ** attempt) + random.uniform(0, 1)\n                        time.sleep(delay)\n                    else:\n                        raise last_exception\n\n        return wrapper\n    return decorator\n\n# Validator that queries external service with retry\n@retry_validation(max_retries=3)\ndef validate_with_external_service(value, context=None) -&gt; bool:\n    '''\n    Example validator that queries an external service\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n\n    # Simulate external service call that may fail\n    import requests\n    try:\n        response = requests.get(f'https://api.example.com/validate/{value}', timeout=5)\n        return response.status_code == 200\n    except requests.RequestException:\n        raise  # Will be retried automatically\n\nclass ExternalValidatedModel(ValidatedModel):\n    external_id: str = field_validated(\n        custom(validate_with_external_service, 'External validation failed')\n    )\n</code></pre> <p>The robust handling of errors is crucial for creating reliable applications that can diagnose and respond appropriately to validation problems, providing useful information for both developers and end-users.</p>"},{"location":"advanced/model-validation/","title":"Model Validation","text":"<p>PyValidX provides the <code>ValidatedModel</code> class that extends Pydantic's <code>BaseModel</code> to add custom validation capabilities.</p>"},{"location":"advanced/model-validation/#validatedmodel-class","title":"ValidatedModel Class","text":"<p>The <code>ValidatedModel</code> class is the core component that enables custom field validation:</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required, min_length\nfrom pyvalidx.string import is_email\n\nclass User(ValidatedModel):\n    name: str = field_validated(is_required(), min_length(2))\n    email: str = field_validated(is_required(), is_email())\n    age: int\n</code></pre>"},{"location":"advanced/model-validation/#automatic-validation","title":"Automatic Validation","text":"<p>Validation occurs automatically when creating model instances:</p> <pre><code># Valid instance\nuser = User(name='John', email='john@example.com', age=25)\n\n# Invalid instance - raises ValidationException\ntry:\n    invalid_user = User(name='', email='invalid-email', age=25)\nexcept ValidationException as e:\n    print(e.validations)\n</code></pre>"},{"location":"advanced/model-validation/#model-configuration","title":"Model Configuration","text":"<p>The <code>ValidatedModel</code> comes with sensible defaults:</p> <pre><code>class ValidatedModel(BaseModel):\n    model_config = ConfigDict(\n        validate_assignment=True,    # Validates on field assignment\n        extra='forbid',             # Prevents extra fields\n        str_strip_whitespace=True,  # Strips whitespace from strings\n    )\n</code></pre>"},{"location":"advanced/model-validation/#custom-model-configuration","title":"Custom Model Configuration","text":"<p>You can override the default configuration:</p> <pre><code>from pydantic import ConfigDict\n\nclass CustomUser(ValidatedModel):\n    model_config = ConfigDict(\n        validate_assignment=False,  # Disable assignment validation\n        extra='allow',             # Allow extra fields\n        str_strip_whitespace=False # Don't strip whitespace\n    )\n\n    name: str = field_validated(is_required())\n    email: str = field_validated(is_email())\n</code></pre>"},{"location":"advanced/model-validation/#validation-context","title":"Validation Context","text":"<p>Some validators need access to other field values through context:</p> <pre><code>from pyvalidx.core import same_as\n\nclass PasswordChangeModel(ValidatedModel):\n    current_password: str = field_validated(is_required())\n    new_password: str = field_validated(is_required(), min_length(8))\n    confirm_password: str = field_validated(\n        same_as('new_password', 'Passwords must match')\n    )\n\n# The context automatically includes all field values\nchange = PasswordChangeModel(\n    current_password='old123',\n    new_password='newSecure456',\n    confirm_password='newSecure456'\n)\n</code></pre>"},{"location":"advanced/model-validation/#inheritance-and-validation","title":"Inheritance and Validation","text":"<p>Validation rules are inherited by subclasses:</p> <pre><code>class BaseUser(ValidatedModel):\n    name: str = field_validated(is_required(), min_length(2))\n    email: str = field_validated(is_required(), is_email())\n\nclass AdminUser(BaseUser):\n    # Inherits name and email validation\n    admin_level: int = field_validated(is_required(), min_value(1))\n\nclass SuperUser(AdminUser):\n    # Inherits all previous validations\n    super_powers: list = field_validated(is_required(), is_not_empty())\n</code></pre>"},{"location":"advanced/model-validation/#optional-fields","title":"Optional Fields","text":"<p>Handle optional fields with proper type annotations:</p> <pre><code>from typing import Optional\n\nclass UserProfile(ValidatedModel):\n    name: str = field_validated(is_required())\n    bio: Optional[str] = field_validated(max_length(500))\n    website: Optional[str] = field_validated(is_url())\n\n    # Optional fields can be None\n    age: Optional[int] = None\n</code></pre>"},{"location":"advanced/model-validation/#complex-validation-scenarios","title":"Complex Validation Scenarios","text":""},{"location":"advanced/model-validation/#conditional-validation","title":"Conditional Validation","text":"<pre><code>from pyvalidx.core import required_if\n\nclass OrderModel(ValidatedModel):\n    payment_method: str = field_validated(\n        is_required(),\n        is_in(['cash', 'credit_card', 'paypal'])\n    )\n\n    card_number: Optional[str] = field_validated(\n        required_if('payment_method', 'credit_card', 'Card number required for credit card payments')\n    )\n\n    paypal_email: Optional[str] = field_validated(\n        required_if('payment_method', 'paypal', 'PayPal email required for PayPal payments'),\n        is_email('Invalid PayPal email format')\n    )\n</code></pre>"},{"location":"advanced/model-validation/#cross-field-validation","title":"Cross-Field Validation","text":"<pre><code>from datetime import datetime, timedelta\n\nclass EventModel(ValidatedModel):\n    start_date: str = field_validated(\n        is_required(),\n        is_date('%Y-%m-%d'),\n        is_future_date('%Y-%m-%d')\n    )\n\n    end_date: str = field_validated(\n        is_required(),\n        is_date('%Y-%m-%d'),\n        is_future_date('%Y-%m-%d')\n    )\n\n    @model_validator(mode='after')\n    def validate_date_order(self) -&gt; 'EventModel':\n        '''\n        Validates that the end date is after the start date\n\n        Returns:\n            EventModel: Self instance if validation passes\n        '''\n        if self.start_date and self.end_date:\n            start = datetime.strptime(self.start_date, '%Y-%m-%d')\n            end = datetime.strptime(self.end_date, '%Y-%m-%d')\n            if end &lt;= start:\n                raise ValueError('End date must be after start date')\n        return self\n</code></pre>"},{"location":"advanced/model-validation/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/model-validation/#validator-ordering","title":"Validator Ordering","text":"<p>Place faster validators first to optimize performance:</p> <pre><code>class OptimizedUser(ValidatedModel):\n    email: str = field_validated(\n        is_required(),      # Fast check first\n        min_length(5),      # Medium speed\n        is_email()          # Slower regex check last\n    )\n</code></pre>"},{"location":"advanced/model-validation/#caching-validation-results","title":"Caching Validation Results","text":"<p>For expensive validations, consider caching:</p> <pre><code>from functools import lru_cache\n\n@lru_cache(maxsize=1000)\ndef expensive_validation(value):\n    # Expensive operation here\n    return True\n\nclass CachedValidationModel(ValidatedModel):\n    data: str = field_validated(\n        custom(expensive_validation, \"Expensive validation failed\")\n    )\n</code></pre>"},{"location":"advanced/model-validation/#error-handling-strategies","title":"Error Handling Strategies","text":""},{"location":"advanced/model-validation/#collecting-all-errors","title":"Collecting All Errors","text":"<pre><code>def validate_user_data(data: dict[str, Any]) -&gt; dict[str, Any]:\n    '''\n    Validates user data and returns result\n\n    Args:\n        data (dict[str, Any]): User data to validate\n\n    Returns:\n        dict[str, Any]: Validation result\n    '''\n    try:\n        user = User(**data)\n        return {'success': True, 'user': user}\n    except ValidationException as e:\n        return {\n            'success': False,\n            'errors': e.validations,\n            'status_code': e.status_code\n        }\n</code></pre>"},{"location":"advanced/model-validation/#custom-error-messages","title":"Custom Error Messages","text":"<pre><code>class UserWithCustomMessages(ValidatedModel):\n    name: str = field_validated(\n        is_required('Please provide your full name'),\n        min_length(2, 'Name must be at least 2 characters long')\n    )\n\n    email: str = field_validated(\n        is_required('Email address is required'),\n        is_email('Please provide a valid email address')\n    )\n</code></pre>"},{"location":"advanced/model-validation/#testing-validated-models","title":"Testing Validated Models","text":"<pre><code>import pytest\nfrom pyvalidx.exception import ValidationException\n\ndef test_valid_user() -&gt; None:\n    '''\n    Test valid user creation\n    '''\n    user = User(name='John Doe', email='john@example.com', age=25)\n    assert user.name == 'John Doe'\n    assert user.email == 'john@example.com'\n\ndef test_invalid_user() -&gt; None:\n    '''\n    Test invalid user creation\n    '''\n    with pytest.raises(ValidationException) as exc_info:\n        User(name='', email='invalid-email', age=25)\n\n    errors = exc_info.value.validations\n    assert 'name' in errors\n    assert 'email' in errors\n</code></pre>"},{"location":"advanced/model-validation/#best-practices","title":"Best Practices","text":"<ol> <li>Keep validators simple: Each validator should check one thing</li> <li>Order validators logically: Fast checks first, expensive checks last</li> <li>Use meaningful error messages: Help users understand what went wrong</li> <li>Combine validators thoughtfully: Don't over-validate</li> <li>Test edge cases: Include tests for boundary conditions</li> <li>Document complex validations: Explain business rules in comments</li> </ol>"},{"location":"api-reference/field-validated/","title":"field_validated API Reference","text":"<p>The <code>field_validated</code> function creates Pydantic fields with custom validators attached.</p>"},{"location":"api-reference/field-validated/#function-definition","title":"Function Definition","text":"<pre><code>def field_validated(\n    *validators: Callable[[Any, Optional[Dict[str, Any]]], bool],\n    **kwargs: Any\n) -&gt; Any:\n    '''\n    Creates a Pydantic field with custom validators.\n\n    Args:\n        *validators: The custom validation functions.\n        **kwargs: The keyword arguments to pass to the Pydantic Field function.\n\n    Returns:\n        Any: A Pydantic field with the custom validators.\n    '''\n</code></pre>"},{"location":"api-reference/field-validated/#parameters","title":"Parameters","text":""},{"location":"api-reference/field-validated/#validators","title":"<code>*validators</code>","text":"<ul> <li>Type: <code>Callable[[Any, Optional[Dict[str, Any]]], bool]</code></li> <li>Description: One or more validator functions to apply to the field</li> <li>Required: At least one validator must be provided</li> </ul>"},{"location":"api-reference/field-validated/#kwargs","title":"<code>**kwargs</code>","text":"<ul> <li>Type: <code>Any</code></li> <li>Description: Additional keyword arguments passed to Pydantic's <code>Field()</code> function</li> <li>Optional: Standard Pydantic field options like <code>default</code>, <code>description</code>, <code>alias</code>, etc.</li> </ul>"},{"location":"api-reference/field-validated/#returns","title":"Returns","text":"<p>Returns a Pydantic <code>Field</code> instance with custom validators attached through the metadata.</p>"},{"location":"api-reference/field-validated/#usage-examples","title":"Usage Examples","text":""},{"location":"api-reference/field-validated/#single-validator","title":"Single Validator","text":"<pre><code>from pyvalidx import field_validated\nfrom pyvalidx.core import is_required\n\nclass User(ValidatedModel):\n    name: str = field_validated(is_required())\n</code></pre>"},{"location":"api-reference/field-validated/#multiple-validators","title":"Multiple Validators","text":"<p>Validators are applied in the order they are specified:</p> <pre><code>from pyvalidx import field_validated\nfrom pyvalidx.core import is_required, min_length, max_length\n\nclass User(ValidatedModel):\n    username: str = field_validated(\n        is_required('Username is required'),\n        min_length(3, 'Username must be at least 3 characters'),\n        max_length(20, 'Username cannot exceed 20 characters')\n    )\n</code></pre>"},{"location":"api-reference/field-validated/#with-pydantic-field-options","title":"With Pydantic Field Options","text":"<p>You can combine custom validators with standard Pydantic field options:</p> <pre><code>from pyvalidx import field_validated\nfrom pyvalidx.core import is_required\nfrom pyvalidx.string import is_email\n\nclass User(ValidatedModel):\n    email: str = field_validated(\n        is_required('Email is required'),\n        is_email('Please provide a valid email address'),\n        description='User's email address',\n        alias='email_address',\n        default=None\n    )\n\n    age: int = field_validated(\n        min_value(0, 'Age cannot be negative'),\n        max_value(150, 'Age must be realistic'),\n        description='User's age in years',\n        default=18,\n        ge=0,  # Pydantic constraint\n        le=150  # Pydantic constraint\n    )\n</code></pre>"},{"location":"api-reference/field-validated/#optional-fields","title":"Optional Fields","text":"<p>Fields can be optional while still having validation when a value is provided:</p> <pre><code>from typing import Optional\n\nclass User(ValidatedModel):\n    name: str = field_validated(is_required())\n\n    # Optional field with validation when provided\n    website: Optional[str] = field_validated(\n        matches_regex(\n            r'^https?://.+',\n            'Website must start with http:// or https://'\n        ),\n        default=None\n    )\n\n    # Optional field with multiple validators\n    phone: Optional[str] = field_validated(\n        is_phone('Please provide a valid phone number'),\n        no_whitespace('Phone number cannot contain spaces'),\n        default=None\n    )\n</code></pre>"},{"location":"api-reference/field-validated/#custom-default-values","title":"Custom Default Values","text":"<pre><code>from datetime import datetime\n\nclass Post(ValidatedModel):\n    title: str = field_validated(\n        is_required('Title is required'),\n        min_length(5, 'Title must be at least 5 characters')\n    )\n\n    created_at: str = field_validated(\n        is_date('%Y-%m-%d %H:%M:%S', 'Invalid datetime format'),\n        default_factory=lambda: datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    )\n\n    status: str = field_validated(\n        is_in(['draft', 'published', 'archived'], 'Invalid status'),\n        default='draft'\n    )\n</code></pre>"},{"location":"api-reference/field-validated/#field-aliases","title":"Field Aliases","text":"<pre><code>class APIUser(ValidatedModel):\n    full_name: str = field_validated(\n        is_required('Full name is required'),\n        min_length(2, 'Name must be at least 2 characters'),\n        alias='name'  # JSON will use 'name' but Python uses 'full_name'\n    )\n\n    email_address: str = field_validated(\n        is_required('Email is required'),\n        is_email('Invalid email format'),\n        alias='email'\n    )\n\n# Usage with alias\nuser = APIUser(**{'name': 'John Doe', 'email': 'john@example.com'})\nprint(user.full_name)  # 'John Doe'\nprint(user.email_address)  # 'john@example.com'\n</code></pre>"},{"location":"api-reference/field-validated/#field-descriptions-and-documentation","title":"Field Descriptions and Documentation","text":"<pre><code>class Product(ValidatedModel):\n    name: str = field_validated(\n        is_required('Product name is required'),\n        min_length(3, 'Name must be at least 3 characters'),\n        max_length(100, 'Name cannot exceed 100 characters'),\n        description='The name of the product',\n        examples=['iPhone 15', 'MacBook Pro']\n    )\n\n    price: float = field_validated(\n        is_required('Price is required'),\n        is_positive('Price must be positive'),\n        description='Product price in USD',\n        examples=[99.99, 1299.00],\n        gt=0  # Additional Pydantic constraint\n    )\n\n    category: str = field_validated(\n        is_required('Category is required'),\n        is_in(\n            ['electronics', 'clothing', 'books', 'home'],\n            'Invalid category'\n        ),\n        description='Product category',\n        examples=['electronics']\n    )\n</code></pre>"},{"location":"api-reference/field-validated/#complex-validation-combinations","title":"Complex Validation Combinations","text":"<pre><code>class UserRegistration(ValidatedModel):\n    # Username with multiple constraints\n    username: str = field_validated(\n        is_required('Username is required'),\n        min_length(3, 'Username must be at least 3 characters'),\n        max_length(20, 'Username cannot exceed 20 characters'),\n        matches_regex(\n            r'^[a-zA-Z0-9_]+$',\n            'Username can only contain letters, numbers, and underscores'\n        ),\n        no_whitespace('Username cannot contain spaces')\n    )\n\n    # Email with validation\n    email: str = field_validated(\n        is_required('Email is required'),\n        is_email('Please provide a valid email address'),\n        max_length(255, 'Email address is too long')\n    )\n\n    # Strong password requirements\n    password: str = field_validated(\n        is_required('Password is required'),\n        min_length(8, 'Password must be at least 8 characters'),\n        is_strong_password(\n            'Password must contain uppercase, lowercase, digit and special character'\n        ),\n        no_whitespace('Password cannot contain spaces')\n    )\n\n    # Password confirmation\n    confirm_password: str = field_validated(\n        is_required('Password confirmation is required'),\n        same_as('password', 'Passwords must match')\n    )\n\n    # Age with business logic\n    age: int = field_validated(\n        is_required('Age is required'),\n        is_integer('Age must be a whole number'),\n        min_value(13, 'Must be at least 13 years old'),\n        max_value(120, 'Age must be realistic')\n    )\n</code></pre>"},{"location":"api-reference/field-validated/#validator-function-requirements","title":"Validator Function Requirements","text":"<p>For a function to work with <code>field_validated</code>, it must:</p> <ol> <li> <p>Have the correct signature: <pre><code>def validator(value: Any, context: Optional[Dict[str, Any]] = None) -&gt; bool:\n</code></pre></p> </li> <li> <p>Return a boolean:</p> </li> <li><code>True</code> if validation passes</li> <li> <p><code>False</code> if validation fails</p> </li> <li> <p>Have a <code>__message__</code> attribute: <pre><code>def my_validator(value, context=None):\n    return some_validation_logic(value)\n\nmy_validator.__message__ = 'Validation failed'\n</code></pre></p> </li> </ol>"},{"location":"api-reference/field-validated/#error-handling","title":"Error Handling","text":"<p>When validation fails, the error message from the validator's <code>__message__</code> attribute is included in the <code>ValidationException</code>:</p> <pre><code>try:\n    user = User(name='')  # Empty name\nexcept ValidationException as e:\n    print(e.validations)\n    # {'name': 'This field is required'}\n</code></pre> <p>For multiple validators on the same field, only the first failing validator's message is returned:</p> <pre><code>class User(ValidatedModel):\n    name: str = field_validated(\n        is_required('Name is required'),        # This fails first\n        min_length(3, 'Name too short')         # This won't be checked\n    )\n\ntry:\n    user = User(name='')\nexcept ValidationException as e:\n    print(e.validations)\n    # {'name': 'Name is required'}\n</code></pre>"},{"location":"api-reference/field-validated/#best-practices","title":"Best Practices","text":"<ol> <li>Order validators logically: Place required checks before length/format checks</li> <li>Use descriptive messages: Provide clear, user-friendly error messages</li> <li>Combine with Pydantic features: Use aliases, defaults, and descriptions for better API design</li> <li>Keep validators focused: Each validator should check one specific rule</li> <li>Document your fields: Use descriptions and examples for API documentation</li> </ol>"},{"location":"api-reference/validated-model/","title":"ValidatedModel API Reference","text":"<p>The <code>ValidatedModel</code> class is the core component of PyValidX that extends Pydantic's <code>BaseModel</code> to support custom field validation.</p>"},{"location":"api-reference/validated-model/#class-definition","title":"Class Definition","text":"<pre><code>class ValidatedModel(BaseModel):\n    '''\n    Model for validation.\n\n    Args:\n        **data (Any): The data to validate.\n\n    Raises:\n        ValidationException: If the validation fails.\n    '''\n</code></pre>"},{"location":"api-reference/validated-model/#configuration","title":"Configuration","text":"<p>The model comes with the following default configuration:</p> <pre><code>model_config = ConfigDict(\n    validate_assignment=True,    # Validates data when fields are assigned\n    extra='forbid',             # Prevents extra fields not defined in the model\n    str_strip_whitespace=True,  # Automatically strips whitespace from strings\n)\n</code></pre>"},{"location":"api-reference/validated-model/#configuration-options","title":"Configuration Options","text":""},{"location":"api-reference/validated-model/#validate_assignment-bool","title":"<code>validate_assignment: bool</code>","text":"<p>When <code>True</code>, validates field values when they are assigned after model creation.</p> <p>Default: <code>True</code></p> <p>Example: <pre><code>user = User(name='John', email='john@example.com')\nuser.email = 'invalid-email'  # Raises ValidationException\n</code></pre></p>"},{"location":"api-reference/validated-model/#extra-str","title":"<code>extra: str</code>","text":"<p>Controls how extra fields (not defined in the model) are handled.</p> <p>Options: - <code>'forbid'</code>: Raises an error if extra fields are provided - <code>'allow'</code>: Allows extra fields - <code>'ignore'</code>: Ignores extra fields silently</p> <p>Default: <code>'forbid'</code></p>"},{"location":"api-reference/validated-model/#str_strip_whitespace-bool","title":"<code>str_strip_whitespace: bool</code>","text":"<p>When <code>True</code>, automatically strips leading and trailing whitespace from string fields.</p> <p>Default: <code>True</code></p> <p>Example: <pre><code>user = User(name='  John  ')  # Becomes 'John'\n</code></pre></p>"},{"location":"api-reference/validated-model/#methods","title":"Methods","text":""},{"location":"api-reference/validated-model/#__init__data-none","title":"<code>__init__(**data) -&gt; None</code>","text":"<p>Creates a new instance of the validated model.</p> <p>Parameters: - <code>**data</code>: Keyword arguments representing field values</p> <p>Raises: - <code>ValidationException</code>: If any field validation fails</p> <p>Example: <pre><code>user = User(name='John Doe', email='john@example.com', age=25)\n</code></pre></p>"},{"location":"api-reference/validated-model/#dict-dictstr-any","title":"<code>dict() -&gt; Dict[str, Any]</code>","text":"<p>Returns the model as a dictionary (inherited from Pydantic).</p> <p>Returns: - <code>Dict[str, Any]</code>: Dictionary representation of the model</p> <p>Example: <pre><code>user = User(name='John', email='john@example.com')\nuser_dict = user.dict()\n# {'name': 'John', 'email': 'john@example.com'}\n</code></pre></p>"},{"location":"api-reference/validated-model/#json-str","title":"<code>json() -&gt; str</code>","text":"<p>Returns the model as a JSON string (inherited from Pydantic).</p> <p>Returns: - <code>str</code>: JSON representation of the model</p> <p>Example: <pre><code>user = User(name='John', email='john@example.com')\nuser_json = user.json()\n# '{'name': 'John', 'email': 'john@example.com'}'\n</code></pre></p>"},{"location":"api-reference/validated-model/#copy-validatedmodel","title":"<code>copy() -&gt; 'ValidatedModel'</code>","text":"<p>Creates a copy of the model (inherited from Pydantic).</p> <p>Returns: - <code>ValidatedModel</code>: A new instance with the same field values</p> <p>Example: <pre><code>user = User(name='John', email='john@example.com')\nuser_copy = user.copy()\n</code></pre></p>"},{"location":"api-reference/validated-model/#class-methods","title":"Class Methods","text":""},{"location":"api-reference/validated-model/#parse_objobj-dictstr-any-validatedmodel","title":"<code>parse_obj(obj: Dict[str, Any]) -&gt; 'ValidatedModel'</code>","text":"<p>Creates a model instance from a dictionary (inherited from Pydantic).</p> <p>Parameters: - <code>obj</code>: Dictionary containing field values</p> <p>Returns: - <code>ValidatedModel</code>: New model instance</p> <p>Raises: - <code>ValidationException</code>: If validation fails</p> <p>Example: <pre><code>user_data = {'name': 'John', 'email': 'john@example.com'}\nuser = User.parse_obj(user_data)\n</code></pre></p>"},{"location":"api-reference/validated-model/#parse_rawdata-str-validatedmodel","title":"<code>parse_raw(data: str) -&gt; 'ValidatedModel'</code>","text":"<p>Creates a model instance from a JSON string (inherited from Pydantic).</p> <p>Parameters: - <code>data</code>: JSON string containing field values</p> <p>Returns: - <code>ValidatedModel</code>: New model instance</p> <p>Raises: - <code>ValidationException</code>: If validation fails</p> <p>Example: <pre><code>json_data = '{'name': 'John', 'email': 'john@example.com'}'\nuser = User.parse_raw(json_data)\n</code></pre></p>"},{"location":"api-reference/validated-model/#usage-examples","title":"Usage Examples","text":""},{"location":"api-reference/validated-model/#basic-model-definition","title":"Basic Model Definition","text":"<pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required, min_length\nfrom pyvalidx.string import is_email\n\nclass User(ValidatedModel):\n    name: str = field_validated(is_required(), min_length(2))\n    email: str = field_validated(is_required(), is_email())\n    age: int\n    bio: str = None  # Optional field without validation\n</code></pre>"},{"location":"api-reference/validated-model/#custom-configuration","title":"Custom Configuration","text":"<pre><code>from pydantic import ConfigDict\n\nclass FlexibleUser(ValidatedModel):\n    model_config = ConfigDict(\n        validate_assignment=False,  # Don't validate on assignment\n        extra='allow',             # Allow extra fields\n        str_strip_whitespace=False # Don't strip whitespace\n    )\n\n    name: str = field_validated(is_required())\n    email: str = field_validated(is_email())\n</code></pre>"},{"location":"api-reference/validated-model/#inheritance","title":"Inheritance","text":"<pre><code>class BaseUser(ValidatedModel):\n    name: str = field_validated(is_required(), min_length(2))\n    email: str = field_validated(is_required(), is_email())\n\nclass AdminUser(BaseUser):\n    admin_level: int = field_validated(is_required(), min_value(1))\n    permissions: list = field_validated(is_required(), is_not_empty())\n\nclass SuperUser(AdminUser):\n    super_powers: list = field_validated(is_required())\n</code></pre>"},{"location":"api-reference/validated-model/#optional-fields","title":"Optional Fields","text":"<pre><code>from typing import Optional\n\nclass UserProfile(ValidatedModel):\n    # Required fields\n    username: str = field_validated(is_required(), min_length(3))\n    email: str = field_validated(is_required(), is_email())\n\n    # Optional fields with validation\n    bio: Optional[str] = field_validated(max_length(500))\n    website: Optional[str] = field_validated(is_url())\n\n    # Optional fields without validation\n    avatar_url: Optional[str] = None\n    last_login: Optional[str] = None\n</code></pre>"},{"location":"api-reference/validated-model/#complex-validation","title":"Complex Validation","text":"<pre><code>from pyvalidx.core import same_as, required_if\nfrom pyvalidx.string import is_strong_password\n\nclass RegistrationModel(ValidatedModel):\n    username: str = field_validated(\n        is_required('Username is required'),\n        min_length(3, 'Username must be at least 3 characters'),\n        max_length(20, 'Username must be at most 20 characters')\n    )\n\n    email: str = field_validated(\n        is_required('Email is required'),\n        is_email('Please provide a valid email address')\n    )\n\n    password: str = field_validated(\n        is_required('Password is required'),\n        min_length(8, 'Password must be at least 8 characters'),\n        is_strong_password('Password is not strong enough')\n    )\n\n    confirm_password: str = field_validated(\n        is_required('Password confirmation is required'),\n        same_as('password', 'Passwords must match')\n    )\n\n    terms_accepted: bool = field_validated(\n        is_required('You must accept the terms'),\n        custom(lambda x, _: x is True, 'Terms must be accepted')\n    )\n</code></pre>"},{"location":"api-reference/validated-model/#model-with-custom-validators","title":"Model with Custom Validators","text":"<pre><code>from pyvalidx.core import custom\n\ndef validate_age_range(value, context=None) -&gt; bool:\n    '''\n    Custom validator for age range.\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n    return 13 &lt;= value &lt;= 120\n\ndef validate_username_format(value, context=None) -&gt; bool:\n    '''\n    Custom validator for username format.\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n    import re\n    return re.match(r'^[a-zA-Z0-9_]+$', value) is not None\n\nclass CustomUser(ValidatedModel):\n    username: str = field_validated(\n        is_required(),\n        custom(validate_username_format, 'Username can only contain letters, numbers, and underscores')\n    )\n\n    age: int = field_validated(\n        is_required(),\n        custom(validate_age_range, 'Age must be between 13 and 120')\n    )\n</code></pre>"},{"location":"api-reference/validated-model/#error-handling","title":"Error Handling","text":"<pre><code>from pyvalidx.exception import ValidationException\n\ndef create_user_safely(user_data: dict[str, Any]) -&gt; dict[str, Any]:\n    '''\n    Safely create a user with proper error handling.\n\n    Args:\n        user_data (dict[str, Any]): User data to create\n\n    Returns:\n        dict[str, Any]: Result of the operation\n    '''\n    try:\n        user = User(**user_data)\n        return {'success': True, 'user': user}\n    except ValidationException as e:\n        return {\n            'success': False,\n            'errors': e.validations,\n            'status_code': e.status_code\n        }\n\n# Usage\nresult = create_user_safely({\n    'name': '',\n    'email': 'invalid-email'\n})\n\nif not result['success']:\n    print('Validation failed:')\n    for field, error in result['errors'].items():\n        print(f'- {field}: {error}')\n</code></pre>"},{"location":"api-reference/validated-model/#testing-models","title":"Testing Models","text":"<pre><code>import pytest\n\ndef test_valid_user_creation() -&gt; None:\n    '''\n    Test creating a valid user.\n\n    Returns:\n        None\n    '''\n    user = User(\n        name='John Doe',\n        email='john@example.com',\n        age=25\n    )\n    assert user.name == 'John Doe'\n    assert user.email == 'john@example.com'\n    assert user.age == 25\n\ndef test_invalid_user_creation() -&gt; None:\n    '''\n    Test validation errors on invalid data.\n\n    Returns:\n        None\n    '''\n    with pytest.raises(ValidationException) as exc_info:\n        User(name='', email='invalid-email', age=-5)\n\n    errors = exc_info.value.validations\n    assert 'name' in errors\n    assert 'email' in errors\n\ndef test_user_serialization() -&gt; None:\n    '''\n    Test model serialization methods.\n\n    Returns:\n        None\n    '''\n    user = User(name='John', email='john@example.com', age=25)\n\n    # Test dict conversion\n    user_dict = user.dict()\n    assert isinstance(user_dict, dict)\n    assert user_dict['name'] == 'John'\n\n    # Test JSON conversion\n    user_json = user.json()\n    assert isinstance(user_json, str)\n    assert 'John' in user_json\n</code></pre>"},{"location":"api-reference/validated-model/#best-practices","title":"Best Practices","text":"<ol> <li>Use type hints: Always provide proper type annotations for fields</li> <li>Validate required fields: Use <code>is_required()</code> for mandatory fields</li> <li>Order validators logically: Place fast validators before slow ones</li> <li>Provide meaningful error messages: Help users understand validation failures</li> <li>Test thoroughly: Include tests for both valid and invalid data</li> <li>Document complex models: Add docstrings for business logic</li> <li>Use inheritance wisely: Share common validation rules through base classes</li> <li>Handle optional fields properly: Use <code>Optional</code> type hints and consider None values</li> </ol>"},{"location":"api-reference/validation-exception/","title":"ValidationException API Reference","text":"<p>The <code>ValidationException</code> class is raised when field validation fails in PyValidX models.</p>"},{"location":"api-reference/validation-exception/#class-definition","title":"Class Definition","text":"<pre><code>class ValidationException(Exception):\n    '''\n    Exception raised when validation fails.\n\n    Attributes:\n        status_code (int): HTTP status code (default: 400)\n        validations (Dict[str, str]): Dictionary of field names and error messages\n    '''\n</code></pre>"},{"location":"api-reference/validation-exception/#attributes","title":"Attributes","text":""},{"location":"api-reference/validation-exception/#status_code-int","title":"<code>status_code: int</code>","text":"<p>The HTTP status code associated with the validation error.</p> <p>Default: <code>400</code> (Bad Request)</p> <p>Example: <pre><code>try:\n    user = User(name='', email='invalid-email')\nexcept ValidationException as e:\n    print(e.status_code)  # 400\n</code></pre></p>"},{"location":"api-reference/validation-exception/#validations-dictstr-str","title":"<code>validations: Dict[str, str]</code>","text":"<p>A dictionary containing field names as keys and their corresponding error messages as values.</p> <p>Example: <pre><code>try:\n    user = User(name='', email='invalid-email')\nexcept ValidationException as e:\n    print(e.validations)\n    # {'name': 'This field is required', 'email': 'Invalid email format'}\n</code></pre></p>"},{"location":"api-reference/validation-exception/#methods","title":"Methods","text":""},{"location":"api-reference/validation-exception/#to_dict-dictstr-any","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Returns the exception as a dictionary containing both status code and validation errors.</p> <p>Returns: - <code>Dict[str, Any]</code>: Dictionary with <code>status_code</code> and <code>validations</code> keys</p> <p>Example: <pre><code>try:\n    user = User(name='', email='invalid-email')\nexcept ValidationException as e:\n    error_dict = e.to_dict()\n    print(error_dict)\n    # {\n    #     'status_code': 400,\n    #     'validations': {\n    #         'name': 'This field is required',\n    #         'email': 'Invalid email format'\n    #     }\n    # }\n</code></pre></p>"},{"location":"api-reference/validation-exception/#to_json-str","title":"<code>to_json() -&gt; str</code>","text":"<p>Returns the exception as a JSON string.</p> <p>Returns: - <code>str</code>: JSON string containing the exception information</p> <p>Example: <pre><code>try:\n    user = User(name='', email='invalid-email')\nexcept ValidationException as e:\n    json_string = e.to_json()\n    print(json_string)\n    # {'status_code': 400, 'validations': {'name': 'This field is required', 'email': 'Invalid email format'}}\n</code></pre></p>"},{"location":"api-reference/validation-exception/#usage-examples","title":"Usage Examples","text":""},{"location":"api-reference/validation-exception/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required\nfrom pyvalidx.string import is_email\nfrom pyvalidx.exception import ValidationException\n\nclass User(ValidatedModel):\n    name: str = field_validated(is_required())\n    email: str = field_validated(is_required(), is_email())\n\ntry:\n    user = User(name='', email='invalid-email')\nexcept ValidationException as e:\n    print(f'Validation failed with status {e.status_code}')\n    for field, message in e.validations.items():\n        print(f'- {field}: {message}')\n</code></pre>"},{"location":"api-reference/validation-exception/#web-api-error-response","title":"Web API Error Response","text":"<pre><code>from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/users', methods=['POST'])\ndef create_user() -&gt; tuple[dict, int]:\n    '''\n    Create a new user.\n\n    Returns:\n        tuple: Tuple of (response, status_code)\n    '''\n    try:\n        user_data = request.get_json()\n        user = User(**user_data)\n        return jsonify({'success': True, 'user': user.dict()}), 201\n    except ValidationException as e:\n        return jsonify(e.to_dict()), e.status_code\n</code></pre>"},{"location":"api-reference/validation-exception/#custom-error-handling","title":"Custom Error Handling","text":"<pre><code>def handle_validation_error(e: ValidationException) -&gt; dict[str, Any]:\n    '''\n    Custom error handler that formats validation errors\n    for better user experience.\n\n    Args:\n        e (ValidationException): ValidationException to handle\n\n    Returns:\n        dict: Formatted error response\n    '''\n    formatted_errors = []\n    for field, message in e.validations.items():\n        formatted_errors.append({\n            'field': field,\n            'message': message,\n            'code': f'INVALID_{field.upper()}'\n        })\n\n    return {\n        'error': 'Validation failed',\n        'status_code': e.status_code,\n        'details': formatted_errors\n    }\n\n# Usage\ntry:\n    user = User(name='', email='invalid')\nexcept ValidationException as e:\n    error_response = handle_validation_error(e)\n    print(error_response)\n</code></pre>"},{"location":"api-reference/validation-exception/#logging-validation-errors","title":"Logging Validation Errors","text":"<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\ndef create_user_with_logging(user_data: dict[str, Any]) -&gt; User:\n    '''\n    Creates a new user with logging.\n\n    Args:\n        user_data (dict[str, Any]): User data to create\n\n    Returns:\n        User: Created user\n    '''\n    try:\n        user = User(**user_data)\n        logger.info(f'User created successfully: {user.email}')\n        return user\n    except ValidationException as e:\n        logger.warning(\n            f'User creation failed: {e.validations}',\n            extra={'validation_errors': e.validations}\n        )\n        raise\n</code></pre>"},{"location":"api-reference/validation-exception/#multiple-model-validation","title":"Multiple Model Validation","text":"<pre><code>def validate_multiple_models(data_list: list[dict[str, Any]]) -&gt; dict[str, Any]:\n    '''\n    Validates multiple model instances and collects all errors.\n\n    Args:\n        data_list (list[dict[str, Any]]): List of user data to validate\n\n    Returns:\n        dict: Validation results\n    '''\n    results = {\n        'successful': [],\n        'failed': [],\n        'total_errors': 0\n    }\n\n    for i, data in enumerate(data_list):\n        try:\n            user = User(**data)\n            results['successful'].append({\n                'index': i,\n                'user': user.dict()\n            })\n        except ValidationException as e:\n            results['failed'].append({\n                'index': i,\n                'errors': e.validations\n            })\n            results['total_errors'] += len(e.validations)\n\n    return results\n</code></pre>"},{"location":"api-reference/validation-exception/#testing-with-validationexception","title":"Testing with ValidationException","text":"<pre><code>import pytest\n\ndef test_user_validation_errors() -&gt; None:\n    '''\n    Test that proper validation errors are raised.\n    '''\n    with pytest.raises(ValidationException) as exc_info:\n        User(name='', email='invalid-email')\n\n    exception = exc_info.value\n\n    # Test status code\n    assert exception.status_code == 400\n\n    # Test specific validation errors\n    assert 'name' in exception.validations\n    assert 'email' in exception.validations\n    assert exception.validations['name'] == 'This field is required'\n    assert 'Invalid email format' in exception.validations['email']\n\ndef test_exception_serialization() -&gt; None:\n    '''\n    Test exception serialization methods.\n    '''\n    try:\n        User(name='', email='invalid')\n    except ValidationException as e:\n        # Test to_dict method\n        error_dict = e.to_dict()\n        assert 'status_code' in error_dict\n        assert 'validations' in error_dict\n\n        # Test to_json method\n        json_str = e.to_json()\n        assert isinstance(json_str, str)\n        assert 'status_code' in json_str\n        assert 'validations' in json_str\n</code></pre>"},{"location":"api-reference/validation-exception/#integration-examples","title":"Integration Examples","text":""},{"location":"api-reference/validation-exception/#fastapi-integration","title":"FastAPI Integration","text":"<pre><code>from fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.exception_handler(ValidationException)\nasync def validation_exception_handler(request, exc: ValidationException) -&gt; JSONResponse:\n    '''\n    Global handler for ValidationException in FastAPI\n\n    Args:\n        request (Request): FastAPI request object\n        exc (ValidationException): ValidationException to handle\n\n    Returns:\n        JSONResponse: JSON response with error details\n    '''\n    return JSONResponse(\n        status_code=exc.status_code,\n        content=exc.to_dict()\n    )\n\n@app.post('/users')\nasync def create_user(user_data: dict[str, Any]) -&gt; dict[str, Any]:\n    '''\n    Create a new user.\n\n    Args:\n        user_data (dict[str, Any]): User data to create\n\n    Returns:\n        dict[str, Any]: Created user\n    '''\n    user = User(**user_data)  # ValidationException handled automatically\n    return {'user': user.dict()}\n</code></pre>"},{"location":"api-reference/validation-exception/#django-integration","title":"Django Integration","text":"<pre><code>from django.http import JsonResponse\nfrom django.views import View\nimport json\n\nclass UserCreateView(View):\n    def post(self, request) -&gt; JsonResponse:\n        '''\n        Create a new user.\n\n        Args:\n            request (HttpRequest): Django request object\n\n        Returns:\n            JsonResponse: JSON response with user data or error details\n        '''\n        try:\n            user_data = json.loads(request.body)\n            user = User(**user_data)\n            return JsonResponse({'success': True, 'user': user.dict()})\n        except ValidationException as e:\n            return JsonResponse(e.to_dict(), status=e.status_code)\n</code></pre>"},{"location":"api-reference/validation-exception/#best-practices","title":"Best Practices","text":"<ol> <li>Always catch ValidationException: Handle validation errors gracefully in your application</li> <li>Use appropriate HTTP status codes: The default 400 is usually correct for validation errors</li> <li>Log validation errors: Keep track of common validation failures for improvement</li> <li>Provide user-friendly messages: Use custom error messages that help users fix their input</li> <li>Test error scenarios: Include tests for validation failures in your test suite</li> <li>Don't expose internal details: Sanitize error messages before showing them to end users</li> </ol>"},{"location":"getting-started/basic-concepts/","title":"Basic Concepts","text":"<p>Understanding the core concepts of PyValidX will help you use the library effectively.</p>"},{"location":"getting-started/basic-concepts/#validators","title":"Validators","text":"<p>Validators are functions that check if a value meets certain criteria. They return <code>True</code> if the value is valid, <code>False</code> otherwise.</p>"},{"location":"getting-started/basic-concepts/#how-validators-work","title":"How Validators Work","text":"<pre><code>from pyvalidx.core import is_required, min_length\nfrom pyvalidx.string import is_email\n\n# Create validators\nrequired_validator = is_required()\nlength_validator = min_length(5)\nemail_validator = is_email()\n\n# Test validators\nprint(required_validator('hello', None))      # True\nprint(required_validator('', None))           # False\nprint(length_validator('hello', None))        # True\nprint(length_validator('hi', None))           # False\nprint(email_validator('test@test.com', None)) # True\nprint(email_validator('invalid', None))       # False\n</code></pre>"},{"location":"getting-started/basic-concepts/#validator-properties","title":"Validator Properties","text":"<p>Every validator has a <code>__message__</code> attribute that contains the error message:</p> <pre><code>from pyvalidx.core import is_required\n\nvalidator = is_required('This field cannot be empty')\nprint(validator.__message__)  # 'This field cannot be empty'\n</code></pre>"},{"location":"getting-started/basic-concepts/#context-aware-validators","title":"Context-Aware Validators","text":"<p>Some validators need access to other field values. The <code>context</code> parameter provides this:</p> <pre><code>from pyvalidx.core import same_as\n\n# This validator compares with another field\npassword_confirm = same_as('password', 'Passwords must match')\n\n# When validating, context contains all field values\n# context = {'password': 'secret123', 'password_confirm': 'secret123'}\n</code></pre>"},{"location":"getting-started/basic-concepts/#validatedmodel","title":"ValidatedModel","text":"<p>The <code>ValidatedModel</code> class extends Pydantic's <code>BaseModel</code> to add custom validation capabilities.</p>"},{"location":"getting-started/basic-concepts/#basic-usage","title":"Basic Usage","text":"<pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required\n\nclass User(ValidatedModel):\n    name: str = field_validated(is_required())\n    email: str = field_validated(is_required())\n    age: int\n\n# Create an instance - validation happens automatically\nuser = User(name='John', email='john@example.com', age=25)\n</code></pre>"},{"location":"getting-started/basic-concepts/#validation-timing","title":"Validation Timing","text":"<p>Validation occurs at three different times:</p> <pre><code># 1. Validation on creation\nuser = User(name='John')\n\n# 2. Validation on assignment (if enabled)\nuser.name = 'Jane'  # Validates automatically\n\n# 3. Manual validation\ncurrent_data = user.validate()  # Returns validated data\n</code></pre>"},{"location":"getting-started/basic-concepts/#field_validated","title":"field_validated","text":"<p>The <code>field_validated</code> function attaches validators to model fields:</p> <pre><code>from pyvalidx import field_validated\nfrom pyvalidx.core import is_required\n\nclass User(ValidatedModel):\n    name: str = field_validated(is_required())\n    #           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    #           This creates a Pydantic field with custom validators\n</code></pre>"},{"location":"getting-started/basic-concepts/#multiple-validators","title":"Multiple Validators","text":"<p>You can apply multiple validators to one field:</p> <pre><code>from pyvalidx.core import is_required, min_length\nfrom pyvalidx.string import is_email\n\nemail: str = field_validated(\n    is_required(),\n    is_email(),\n    min_length(5)\n)\n</code></pre>"},{"location":"getting-started/basic-concepts/#validator-order","title":"Validator Order","text":"<p>Validators are executed in the order you specify them. If any validator fails, the remaining validators are not executed:</p> <pre><code>field_validated(\n    is_required(),      # Runs first\n    min_length(8),      # Runs second (if first passes)\n    is_strong_password() # Runs third (if first two pass)\n)\n</code></pre>"},{"location":"getting-started/basic-concepts/#validationexception","title":"ValidationException","text":"<p>When validation fails, PyValidX raises a <code>ValidationException</code>:</p> <pre><code>from pyvalidx.exception import ValidationException\n\ntry:\n    user = User(name='', email='invalid')\nexcept ValidationException as e:\n    print(e.status_code)  # 400\n    print(e.validations)  # {'name': 'This field is required', ...}\n    print(e.to_dict())    # Complete error structure\n    print(e.to_json())    # JSON string\n</code></pre>"},{"location":"getting-started/basic-concepts/#error-structure","title":"Error Structure","text":"<p>The exception provides structured error information:</p> <pre><code>{\n    'status_code': 400,\n    'validations': {\n        'name': 'This field is required',\n        'email': 'Invalid email format',\n        'age': 'Must be a positive number'\n    }\n}\n</code></pre>"},{"location":"getting-started/basic-concepts/#optional-fields-and-none-values","title":"Optional Fields and None Values","text":"<p>PyValidX handles <code>None</code> values gracefully:</p> <pre><code>from typing import Optional\n\nclass User(ValidatedModel):\n    name: str = field_validated(is_required())\n    nickname: Optional[str] = field_validated(min_length(2))\n    #         ^^^^^^^^^^^^^ Optional field\n    bio: Optional[str] = None  # No validation\n</code></pre>"},{"location":"getting-started/basic-concepts/#how-none-values-work","title":"How None Values Work","text":"<ul> <li>Required validators: Fail if value is <code>None</code></li> <li>Other validators: Return <code>True</code> if value is <code>None</code> (skip validation)</li> <li>Optional fields: Can be <code>None</code> without triggering validation errors</li> </ul> <pre><code># This works - nickname is optional\nuser = User(name='John', nickname=None)\n\n# This fails - name is required\ntry:\n    user = User()\nexcept ValidationException as e:\n    print(e.validations)  # {'name': 'This field is required'}\n</code></pre>"},{"location":"getting-started/basic-concepts/#validation-context","title":"Validation Context","text":"<p>The validation context contains all field values and is passed to validators that need it:</p> <pre><code>from pyvalidx.core import same_as\n\nclass PasswordForm(ValidatedModel):\n    password: str = field_validated(is_required())\n    confirm_password: str = field_validated(\n        same_as('password')  # This validator uses context\n    )\n\n# When validating confirm_password, context will be:\n# {'password': 'secret123', 'confirm_password': 'secret123'}\n</code></pre>"},{"location":"getting-started/basic-concepts/#custom-validators","title":"Custom Validators","text":"<p>You can create custom validators using the <code>custom</code> function:</p> <pre><code>from pyvalidx.core import custom\n\ndef is_even(value, context=None) -&gt; bool:\n    '''\n    Check if a number is even.\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n    return value % 2 == 0\n\nclass NumberModel(ValidatedModel):\n    even_number: int = field_validated(\n        custom(is_even, 'Number must be even')\n    )\n</code></pre>"},{"location":"getting-started/basic-concepts/#custom-validator-requirements","title":"Custom Validator Requirements","text":"<p>Custom validators must: 1. Accept two parameters: <code>value</code> and <code>context</code> 2. Return <code>True</code> for valid values, <code>False</code> for invalid 3. Handle <code>None</code> values appropriately (usually return <code>True</code>)</p>"},{"location":"getting-started/basic-concepts/#combining-concepts","title":"Combining Concepts","text":"<p>Here's how all concepts work together:</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required, min_length, same_as, custom\nfrom pyvalidx.string import is_email, is_strong_password\nfrom typing import Optional\n\ndef is_adult(value, context=None) -&gt; bool:\n    '''\n    Custom validator to check if age indicates adult.\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n    return value &gt;= 18\n\nclass UserRegistration(ValidatedModel):\n    # Required field with multiple validators\n    username: str = field_validated(\n        is_required('Username is required'),\n        min_length(3, 'Username too short')\n    )\n\n    # Email validation\n    email: str = field_validated(\n        is_required('Email is required'),\n        is_email('Invalid email format')\n    )\n\n    # Password with custom and built-in validators\n    password: str = field_validated(\n        is_required('Password is required'),\n        min_length(8, 'Password too short'),\n        is_strong_password('Password not strong enough')\n    )\n\n    # Context-aware validator\n    confirm_password: str = field_validated(\n        is_required('Password confirmation required'),\n        same_as('password', 'Passwords must match')\n    )\n\n    # Custom validator\n    age: int = field_validated(\n        is_required('Age is required'),\n        custom(is_adult, 'Must be 18 or older')\n    )\n\n    # Optional field\n    bio: Optional[str] = field_validated(\n        min_length(10, 'Bio too short')\n    )\n\n# Usage\ntry:\n    user = UserRegistration(\n        username='johndoe',\n        email='john@example.com',\n        password='SecurePass123!',\n        confirm_password='SecurePass123!',\n        age=25,\n        bio='I love programming'\n    )\n    print('Registration successful!')\nexcept ValidationException as e:\n    print('Registration failed:')\n    for field, error in e.validations.items():\n        print(f'- {field}: {error}')\n</code></pre>"},{"location":"getting-started/basic-concepts/#best-practices","title":"Best Practices","text":"<ol> <li>Start simple: Begin with basic validators and add complexity as needed</li> <li>Use meaningful names: Choose descriptive field names and error messages</li> <li>Order validators logically: Put fast checks before slow ones</li> <li>Handle optional fields: Use <code>Optional</code> type hints for nullable fields</li> <li>Test thoroughly: Include tests for both valid and invalid data</li> <li>Document custom validators: Explain what your custom validators do</li> <li>Keep validators focused: Each validator should check one specific thing</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>PyValidX requires Python 3.10 or higher and depends on:</p> <ul> <li>Pydantic 2.11.7+ - For model validation and type checking</li> <li>typing-extensions - For enhanced type annotations</li> </ul>"},{"location":"getting-started/installation/#install-pyvalidx","title":"Install PyValidX","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<pre><code>pip install pyvalidx\n</code></pre>"},{"location":"getting-started/installation/#using-poetry","title":"Using poetry","text":"<pre><code>poetry add pyvalidx\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to PyValidX or need the latest development version:</p> <pre><code># Clone the repository\ngit clone https://github.com/harrison-gaviria/pyvalidx.git\ncd pyvalidx\n\n# Install in development mode\npip install -e .\n\n# Or with poetry\npoetry install\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that PyValidX is working correctly:</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required\n\nclass TestModel(ValidatedModel):\n    name: str = field_validated(is_required())\n\n# This should work without errors\ntest = TestModel(name='PyValidX')\nprint(f'Installation successful! Created model with name: {test.name}')\n</code></pre> <p>If you see the success message, PyValidX is installed and ready to use!</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn the basics in 5 minutes</li> <li>Basic Concepts - Understand core PyValidX concepts</li> <li>Core Validators - Explore available validators</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with PyValidX in just a few minutes!</p>"},{"location":"getting-started/quick-start/#your-first-validated-model","title":"Your First Validated Model","text":"<p>Let's create a simple user model with validation:</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required\nfrom pyvalidx.string import is_email\n\nclass User(ValidatedModel):\n    name: str = field_validated(is_required())\n    email: str = field_validated(is_required(), is_email())\n    age: int = field_validated(is_required())\n\n# Create a valid user\nuser = User(\n    name='John Doe',\n    email='john@example.com',\n    age=25\n)\nprint(f'Created user: {user.name}')\n\n# Try to create an invalid user\ntry:\n    invalid_user = User(name='', email='invalid-email', age=25)\nexcept ValidationException as e:\n    print('Validation failed:')\n    for field, error in e.validations.items():\n        print(f'- {field}: {error}')\n</code></pre>"},{"location":"getting-started/quick-start/#multiple-validators-on-one-field","title":"Multiple Validators on One Field","text":"<p>You can apply multiple validators to a single field:</p> <pre><code>from pyvalidx.core import min_length, max_length\nfrom pyvalidx.string import is_strong_password\n\nclass SecureUser(ValidatedModel):\n    username: str = field_validated(\n        is_required(),\n        min_length(3),\n        max_length(20)\n    )\n    password: str = field_validated(\n        is_required(),\n        min_length(8),\n        is_strong_password()\n    )\n\n# This will validate all conditions\nsecure_user = SecureUser(\n    username='alice123',\n    password='MySecurePass123!'\n)\n</code></pre>"},{"location":"getting-started/quick-start/#custom-error-messages","title":"Custom Error Messages","text":"<p>Customize error messages for better user experience:</p> <pre><code>from pyvalidx.core import is_required\n\nclass Product(ValidatedModel):\n    name: str = field_validated(\n        is_required('Product name is required')\n    )\n    price: float = field_validated(\n        is_required('Price must be specified')\n    )\n\ntry:\n    Product(name='')\nexcept ValidationException as e:\n    print(e.to_dict())\n    # Custom messages will be shown\n</code></pre>"},{"location":"getting-started/quick-start/#conditional-validation","title":"Conditional Validation","text":"<p>Make fields required based on other fields:</p> <pre><code>from pyvalidx.core import required_if\n\nclass Order(ValidatedModel):\n    payment_method: str = field_validated(is_required())\n    credit_card_number: str = field_validated(\n        required_if('payment_method', 'credit_card',\n                   'Credit card number required for card payments'),\n        default=''\n    )\n\n# Valid - no card payment\norder1 = Order(payment_method='cash')\n\n# Valid - card payment with number\norder2 = Order(\n    payment_method='credit_card',\n    credit_card_number='4111111111111111'\n)\n\n# Invalid - card payment without number\ntry:\n    Order(payment_method='credit_card')\nexcept ValidationException as e:\n    print('Card number required!')\n</code></pre>"},{"location":"getting-started/quick-start/#working-with-dates","title":"Working with Dates","text":"<p>Validate date fields easily:</p> <pre><code>from pyvalidx.date import is_date, is_future_date\n\nclass Event(ValidatedModel):\n    name: str = field_validated(is_required())\n    start_date: str = field_validated(\n        is_required(),\n        is_date('%Y-%m-%d'),\n        is_future_date('%Y-%m-%d', 'Event must be in the future')\n    )\n\n# Valid future event\nevent = Event(name='Conference', start_date='2025-12-01')\n</code></pre>"},{"location":"getting-started/quick-start/#numeric-validation","title":"Numeric Validation","text":"<p>Validate numbers with range constraints:</p> <pre><code>from pyvalidx.numeric import is_positive, min_value, max_value\n\nclass Product(ValidatedModel):\n    name: str = field_validated(is_required())\n    price: float = field_validated(\n        is_required(),\n        is_positive('Price must be positive'),\n        min_value(0.01, 'Minimum price is $0.01')\n    )\n    quantity: int = field_validated(\n        is_required(),\n        min_value(1),\n        max_value(1000, 'Maximum quantity is 1000')\n    )\n\nproduct = Product(name='Widget', price=19.99, quantity=5)\n</code></pre>"},{"location":"getting-started/quick-start/#whats-next","title":"What's Next?","text":"<p>Now that you've seen the basics, explore more advanced features:</p> <ul> <li>Basic Concepts - Understand PyValidX architecture</li> <li>All Validators - Complete validator reference</li> <li>Custom Validators - Create your own validators</li> </ul>"},{"location":"validators/core/","title":"Core Validators","text":"<p>Core validators provide basic validation functionalities that are fundamental for most use cases.</p>"},{"location":"validators/core/#is_required","title":"is_required","text":"<p>Validates that the field is not <code>None</code>, empty string, or empty list.</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required\n\nclass UserModel(ValidatedModel):\n    name: str = field_validated(is_required())\n    email: str = field_validated(is_required('Email is mandatory'))\n\n# Usage\ntry:\n    user = UserModel(name='', email='john@example.com')\nexcept ValidationException as e:\n    print(e.validations)  # {'name': 'This field is required'}\n</code></pre>"},{"location":"validators/core/#parameters","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'This field is required'</li> </ul>"},{"location":"validators/core/#min_length","title":"min_length","text":"<p>Validates that the field has at least the specified length.</p> <pre><code>from pyvalidx.core import min_length\n\nclass ProductModel(ValidatedModel):\n    name: str = field_validated(min_length(3))\n    description: str = field_validated(min_length(10, 'Description too short'))\n\n# Usage\nproduct = ProductModel(\n    name='iPhone',\n    description='Latest smartphone model'\n)\n</code></pre>"},{"location":"validators/core/#parameters_1","title":"Parameters","text":"<ul> <li><code>length</code> (int): Minimum required length</li> <li><code>message</code> (str, optional): Custom error message</li> </ul>"},{"location":"validators/core/#max_length","title":"max_length","text":"<p>Validates that the field has at most the specified length.</p> <pre><code>from pyvalidx.core import max_length\n\nclass CommentModel(ValidatedModel):\n    title: str = field_validated(max_length(100))\n    content: str = field_validated(max_length(500, 'Comment too long'))\n\n# Usage\ncomment = CommentModel(\n    title='Great product!',\n    content='I really enjoyed using this product...'\n)\n</code></pre>"},{"location":"validators/core/#parameters_2","title":"Parameters","text":"<ul> <li><code>length</code> (int): Maximum allowed length</li> <li><code>message</code> (str, optional): Custom error message</li> </ul>"},{"location":"validators/core/#custom","title":"custom","text":"<p>Wraps a custom validation function with a message.</p> <pre><code>from pyvalidx.core import custom\n\ndef is_even(value, context=None) -&gt; bool:\n    '''\n    Validates that the number is even\n\n    Args:\n        value (Any): Value to validate\n        context (Dict[str, Any], optional): Context containing other field values\n\n    Returns:\n        bool: True if validation passes, False otherwise\n    '''\n    if value is None:\n        return True\n    return value % 2 == 0\n\nclass NumberModel(ValidatedModel):\n    even_number: int = field_validated(\n        custom(is_even, 'Number must be even')\n    )\n\n# Usage\nnumber = NumberModel(even_number=4)  # Valid\n</code></pre>"},{"location":"validators/core/#parameters_3","title":"Parameters","text":"<ul> <li><code>validator_func</code>: Function that receives (value, context) and returns bool</li> <li><code>message</code> (str): Error message if validation fails</li> </ul>"},{"location":"validators/core/#same_as","title":"same_as","text":"<p>Validates that the field has the same value as another field.</p> <pre><code>from pyvalidx.core import same_as\n\nclass RegistrationModel(ValidatedModel):\n    password: str = field_validated(is_required())\n    confirm_password: str = field_validated(\n        same_as('password', 'Passwords must match')\n    )\n\n# Usage\nregistration = RegistrationModel(\n    password='mypass123',\n    confirm_password='mypass123'\n)\n</code></pre>"},{"location":"validators/core/#parameters_4","title":"Parameters","text":"<ul> <li><code>other_field</code> (str): Name of the field to compare</li> <li><code>message</code> (str, optional): Custom error message</li> </ul>"},{"location":"validators/core/#is_not_empty","title":"is_not_empty","text":"<p>Validates that the field is not empty (different from <code>is_required</code>).</p> <pre><code>from pyvalidx.core import is_not_empty\n\nclass TagModel(ValidatedModel):\n    tags: list = field_validated(is_not_empty('Tags list cannot be empty'))\n\n# Usage\ntag_model = TagModel(tags=['python', 'validation'])\n</code></pre>"},{"location":"validators/core/#parameters_5","title":"Parameters","text":"<ul> <li><code>message</code> (str): Error message if the field is empty</li> </ul>"},{"location":"validators/core/#required_if","title":"required_if","text":"<p>Validates that the field is required if another field has a specific value.</p> <pre><code>from pyvalidx.core import required_if\n\nclass OrderModel(ValidatedModel):\n    payment_method: str = field_validated(is_required())\n    card_number: str = field_validated(\n        required_if('payment_method', 'credit_card', 'Card number required for credit card payments')\n    )\n\n# Usage\norder = OrderModel(\n    payment_method='credit_card',\n    card_number='1234-5678-9012-3456'\n)\n</code></pre>"},{"location":"validators/core/#parameters_6","title":"Parameters","text":"<ul> <li><code>other_field</code> (str): Field that conditions the validation</li> <li><code>other_value</code> (Any): Value that makes this field required</li> <li><code>message</code> (str): Custom error message</li> </ul>"},{"location":"validators/core/#combining-validators","title":"Combining Validators","text":"<p>You can combine multiple core validators:</p> <pre><code>class UserProfileModel(ValidatedModel):\n    username: str = field_validated(\n        is_required('Username is required'),\n        min_length(3, 'Username too short'),\n        max_length(20, 'Username too long')\n    )\n    bio: str = field_validated(\n        max_length(500, 'Bio too long')\n    )\n    website: str = field_validated(\n        required_if('bio', '', 'Website required if no bio provided')\n    )\n</code></pre>"},{"location":"validators/date/","title":"Date Validators","text":"<p>Date validators provide functionalities for validating dates and times in different formats.</p>"},{"location":"validators/date/#is_date","title":"is_date","text":"<p>Validates that the field is a valid date in the specified format.</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.date import is_date\n\nclass EventModel(ValidatedModel):\n    event_date: str = field_validated(is_date())\n    custom_date: str = field_validated(\n        is_date('%d/%m/%Y', 'Date must be in DD/MM/YYYY format')\n    )\n\n# Valid usage\nevent = EventModel(\n    event_date='2024-12-25',\n    custom_date='25/12/2024'\n)\n\n# Invalid usage\ntry:\n    invalid_event = EventModel(event_date='invalid-date')\nexcept ValidationException as e:\n    print(e.validations)  # {'event_date': 'Invalid date format'}\n</code></pre>"},{"location":"validators/date/#parameters","title":"Parameters","text":"<ul> <li><code>format</code> (str, optional): Expected date format. Default: '%Y-%m-%d'</li> <li><code>message</code> (str, optional): Custom error message. Default: 'Invalid date format'</li> </ul>"},{"location":"validators/date/#is_future_date","title":"is_future_date","text":"<p>Validates that the date is in the future.</p> <pre><code>from pyvalidx.date import is_future_date\n\nclass AppointmentModel(ValidatedModel):\n    appointment_date: str = field_validated(is_future_date())\n    deadline: str = field_validated(\n        is_future_date('%d-%m-%Y', 'Deadline must be in the future')\n    )\n\n# Valid usage\nfrom datetime import datetime, timedelta\ntomorrow = (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d')\n\nappointment = AppointmentModel(\n    appointment_date=tomorrow,\n    deadline=(datetime.now() + timedelta(days=7)).strftime('%d-%m-%Y')\n)\n\n# Invalid usage\ntry:\n    past_appointment = AppointmentModel(appointment_date='2020-01-01')\nexcept ValidationException as e:\n    print(e.validations)  # {'appointment_date': 'Date must be in the future'}\n</code></pre>"},{"location":"validators/date/#parameters_1","title":"Parameters","text":"<ul> <li><code>format</code> (str, optional): Expected date format. Default: '%Y-%m-%d'</li> <li><code>message</code> (str, optional): Custom error message. Default: 'Date must be in the future'</li> </ul>"},{"location":"validators/date/#is_past_date","title":"is_past_date","text":"<p>Validates that the date is in the past.</p> <pre><code>from pyvalidx.date import is_past_date\n\nclass HistoryModel(ValidatedModel):\n    birth_date: str = field_validated(is_past_date())\n    graduation_date: str = field_validated(\n        is_past_date('%d/%m/%Y', 'Graduation date must be in the past')\n    )\n\n# Valid usage\nhistory = HistoryModel(\n    birth_date='1990-03-15',\n    graduation_date='15/06/2020'\n)\n\n# Invalid usage\ntry:\n    future_birth = HistoryModel(birth_date='2030-01-01')\nexcept ValidationException as e:\n    print(e.validations)  # {'birth_date': 'Date must be in the past'}\n</code></pre>"},{"location":"validators/date/#parameters_2","title":"Parameters","text":"<ul> <li><code>format</code> (str, optional): Expected date format. Default: '%Y-%m-%d'</li> <li><code>message</code> (str, optional): Custom error message. Default: 'Date must be in the past'</li> </ul>"},{"location":"validators/date/#is_today","title":"is_today","text":"<p>Validates that the date is exactly today.</p> <pre><code>from pyvalidx.date import is_today\n\nclass DailyReportModel(ValidatedModel):\n    report_date: str = field_validated(is_today())\n    submission_date: str = field_validated(\n        is_today('%d-%m-%Y', 'Report must be submitted today')\n    )\n\n# Valid usage\nfrom datetime import datetime\ntoday = datetime.now().strftime('%Y-%m-%d')\n\nreport = DailyReportModel(\n    report_date=today,\n    submission_date=datetime.now().strftime('%d-%m-%Y')\n)\n\n# Invalid usage\ntry:\n    wrong_report = DailyReportModel(report_date='2024-01-01')\nexcept ValidationException as e:\n    print(e.validations)  # {'report_date': 'Date must be today'}\n</code></pre>"},{"location":"validators/date/#parameters_3","title":"Parameters","text":"<ul> <li><code>format</code> (str, optional): Expected date format. Default: '%Y-%m-%d'</li> <li><code>message</code> (str, optional): Custom error message. Default: 'Date must be today'</li> </ul>"},{"location":"validators/date/#complete-example-hotel-reservation-system","title":"Complete Example: Hotel Reservation System","text":"<pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required\nfrom pyvalidx.date import is_date, is_future_date\nfrom datetime import datetime, timedelta\n\nclass HotelReservationModel(ValidatedModel):\n    guest_name: str = field_validated(is_required('Guest name is required'))\n\n    check_in_date: str = field_validated(\n        is_required('Check-in date is required'),\n        is_date('%Y-%m-%d', 'Check-in date must be in YYYY-MM-DD format'),\n        is_future_date('%Y-%m-%d', 'Check-in date must be in the future')\n    )\n\n    check_out_date: str = field_validated(\n        is_required('Check-out date is required'),\n        is_date('%Y-%m-%d', 'Check-out date must be in YYYY-MM-DD format'),\n        is_future_date('%Y-%m-%d', 'Check-out date must be in the future')\n    )\n\n# Valid usage\ntomorrow = (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d')\nnext_week = (datetime.now() + timedelta(days=7)).strftime('%Y-%m-%d')\n\nreservation = HotelReservationModel(\n    guest_name='John Doe',\n    check_in_date=tomorrow,\n    check_out_date=next_week\n)\n</code></pre>"},{"location":"validators/date/#example-birth-date-validation","title":"Example: Birth Date Validation","text":"<pre><code>from pyvalidx.date import is_past_date\nfrom pyvalidx.numeric import min_value, max_value\nfrom datetime import datetime\n\nclass PersonModel(ValidatedModel):\n    name: str = field_validated(is_required())\n    birth_date: str = field_validated(\n        is_required('Birth date is required'),\n        is_date('%Y-%m-%d', 'Birth date must be in YYYY-MM-DD format'),\n        is_past_date('%Y-%m-%d', 'Birth date must be in the past')\n    )\n\n    @property\n    def age(self) -&gt; int:\n        '''\n        Calculates the age based on the birth date\n\n        Returns:\n            int: Age in years\n        '''\n        birth = datetime.strptime(self.birth_date, '%Y-%m-%d')\n        today = datetime.now()\n        return today.year - birth.year - ((today.month, today.day) &lt; (birth.month, birth.day))\n\n# Usage\nperson = PersonModel(\n    name='Alice Smith',\n    birth_date='1990-03-15'\n)\nprint(f'{person.name} is {person.age} years old')\n</code></pre>"},{"location":"validators/date/#example-event-validation-with-multiple-dates","title":"Example: Event Validation with Multiple Dates","text":"<pre><code>class ConferenceModel(ValidatedModel):\n    title: str = field_validated(is_required())\n\n    registration_deadline: str = field_validated(\n        is_date('%Y-%m-%d'),\n        is_future_date('%Y-%m-%d', 'Registration deadline must be in the future')\n    )\n\n    event_start: str = field_validated(\n        is_date('%Y-%m-%d'),\n        is_future_date('%Y-%m-%d', 'Event start date must be in the future')\n    )\n\n    event_end: str = field_validated(\n        is_date('%Y-%m-%d'),\n        is_future_date('%Y-%m-%d', 'Event end date must be in the future')\n    )\n\n# Usage\nfrom datetime import datetime, timedelta\n\nconference = ConferenceModel(\n    title='Python Conference 2024',\n    registration_deadline=(datetime.now() + timedelta(days=30)).strftime('%Y-%m-%d'),\n    event_start=(datetime.now() + timedelta(days=60)).strftime('%Y-%m-%d'),\n    event_end=(datetime.now() + timedelta(days=63)).strftime('%Y-%m-%d')\n)\n</code></pre>"},{"location":"validators/date/#supported-date-formats","title":"Supported Date Formats","text":"Format Example Description <code>%Y-%m-%d</code> 2024-12-25 Year-Month-Day (ISO) <code>%d/%m/%Y</code> 25/12/2024 Day/Month/Year (European) <code>%m/%d/%Y</code> 12/25/2024 Month/Day/Year (American) <code>%Y-%m-%d %H:%M:%S</code> 2024-12-25 14:30:00 Full date and time <code>%d-%m-%Y</code> 25-12-2024 Day-Month-Year with hyphens <code>%Y/%m/%d</code> 2024/12/25 Year/Month/Day with slashes"},{"location":"validators/date/#important-notes","title":"Important Notes","text":"<ul> <li>Date validators return <code>True</code> if the value is <code>None</code> (for optional fields)</li> <li>Dates are compared using <code>datetime.now()</code> at validation time</li> <li>If the date format is invalid, the validator returns <code>False</code></li> <li>You can combine date validators with other validators for more complex validations</li> <li>For optional date fields, consider using <code>Optional[str]</code> in the type annotation</li> </ul>"},{"location":"validators/numeric/","title":"Numeric Validators","text":"<p>Numeric validators provide functionalities for validating numbers, ranges, and specific numeric types.</p>"},{"location":"validators/numeric/#is_positive","title":"is_positive","text":"<p>Validates that the field is a positive number.</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.numeric import is_positive\n\nclass ProductModel(ValidatedModel):\n    price: float = field_validated(is_positive())\n    discount: float = field_validated(is_positive('Discount must be positive'))\n\n# Valid usage\nproduct = ProductModel(\n    price=29.99,\n    discount=5.0\n)\n\n# Invalid usage\ntry:\n    invalid_product = ProductModel(price=-10.0)\nexcept ValidationException as e:\n    print(e.validations)  # {'price': 'Must be a positive number'}\n</code></pre>"},{"location":"validators/numeric/#parameters","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Must be a positive number'</li> </ul>"},{"location":"validators/numeric/#is_integer","title":"is_integer","text":"<p>Validates that the field is an integer.</p> <pre><code>from pyvalidx.numeric import is_integer\n\nclass InventoryModel(ValidatedModel):\n    quantity: int = field_validated(is_integer())\n    reorder_level: int = field_validated(is_integer('Reorder level must be an integer'))\n\n# Valid usage\ninventory = InventoryModel(\n    quantity=100,\n    reorder_level=10\n)\n\n# Invalid usage\ntry:\n    invalid_inventory = InventoryModel(quantity=50.5)\nexcept ValidationException as e:\n    print(e.validations)  # {'quantity': 'Must be an integer'}\n</code></pre>"},{"location":"validators/numeric/#parameters_1","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Must be an integer'</li> </ul>"},{"location":"validators/numeric/#is_float","title":"is_float","text":"<p>Validates that the field is a floating-point number.</p> <pre><code>from pyvalidx.numeric import is_float\n\nclass MeasurementModel(ValidatedModel):\n    weight: float = field_validated(is_float())\n    height: float = field_validated(is_float('Height must be a decimal number'))\n\n# Valid usage\nmeasurement = MeasurementModel(\n    weight=70.5,\n    height=1.75\n)\n</code></pre>"},{"location":"validators/numeric/#parameters_2","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Must be a float'</li> </ul>"},{"location":"validators/numeric/#max_value","title":"max_value","text":"<p>Validates that the field has a value less than or equal to the specified maximum.</p> <pre><code>from pyvalidx.numeric import max_value\n\nclass ScoreModel(ValidatedModel):\n    exam_score: float = field_validated(max_value(100))\n    rating: int = field_validated(max_value(5, 'Rating cannot exceed 5 stars'))\n\n# Valid usage\nscore = ScoreModel(\n    exam_score=95.5,\n    rating=4\n)\n\n# Invalid usage\ntry:\n    invalid_score = ScoreModel(exam_score=110)\nexcept ValidationException as e:\n    print(e.validations)  # {'exam_score': 'Must be less than or equal to 100'}\n</code></pre>"},{"location":"validators/numeric/#parameters_3","title":"Parameters","text":"<ul> <li><code>max_val</code> (Union[int, float]): Maximum allowed value</li> <li><code>message</code> (str, optional): Custom error message</li> </ul>"},{"location":"validators/numeric/#min_value","title":"min_value","text":"<p>Validates that the field has a value greater than or equal to the specified minimum.</p> <pre><code>from pyvalidx.numeric import min_value\n\nclass PersonModel(ValidatedModel):\n    age: int = field_validated(min_value(0))\n    salary: float = field_validated(min_value(0, 'Salary cannot be negative'))\n\n# Valid usage\nperson = PersonModel(\n    age=25,\n    salary=50000.0\n)\n\n# Invalid usage\ntry:\n    invalid_person = PersonModel(age=-5)\nexcept ValidationException as e:\n    print(e.validations)  # {'age': 'Must be greater than or equal to 0'}\n</code></pre>"},{"location":"validators/numeric/#parameters_4","title":"Parameters","text":"<ul> <li><code>min_val</code> (Union[int, float]): Minimum allowed value</li> <li><code>message</code> (str, optional): Custom error message</li> </ul>"},{"location":"validators/numeric/#combining-numeric-validators","title":"Combining Numeric Validators","text":"<p>You can combine multiple validators to create more complex validations:</p> <pre><code>from pyvalidx.numeric import is_positive, min_value, max_value, is_integer\n\nclass ProductRatingModel(ValidatedModel):\n    rating: int = field_validated(\n        is_integer('Rating must be a whole number'),\n        min_value(1, 'Rating must be at least 1'),\n        max_value(5, 'Rating cannot exceed 5')\n    )\n\n    price: float = field_validated(\n        is_positive('Price must be positive'),\n        max_value(10000, 'Price cannot exceed $10,000')\n    )\n\n# Valid usage\nproduct_rating = ProductRatingModel(\n    rating=4,\n    price=299.99\n)\n</code></pre>"},{"location":"validators/numeric/#complete-example-grading-system","title":"Complete Example: Grading System","text":"<pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required\nfrom pyvalidx.numeric import is_integer, is_float, min_value, max_value, is_positive\n\nclass StudentGradeModel(ValidatedModel):\n    student_id: int = field_validated(\n        is_required('Student ID is required'),\n        is_integer('Student ID must be an integer'),\n        is_positive('Student ID must be positive')\n    )\n\n    exam_score: float = field_validated(\n        is_required('Exam score is required'),\n        is_float('Exam score must be a decimal number'),\n        min_value(0, 'Score cannot be negative'),\n        max_value(100, 'Score cannot exceed 100')\n    )\n\n    attendance_percentage: float = field_validated(\n        is_float('Attendance must be a decimal number'),\n        min_value(0, 'Attendance cannot be negative'),\n        max_value(100, 'Attendance cannot exceed 100%')\n    )\n\n    extra_credit: int = field_validated(\n        is_integer('Extra credit must be whole points'),\n        min_value(0, 'Extra credit cannot be negative'),\n        max_value(10, 'Extra credit cannot exceed 10 points')\n    )\n\n# Usage\ngrade = StudentGradeModel(\n    student_id=12345,\n    exam_score=87.5,\n    attendance_percentage=95.0,\n    extra_credit=3\n)\n\nprint(f'Final score: {grade.exam_score + grade.extra_credit}')\n</code></pre>"},{"location":"validators/numeric/#complex-range-validation","title":"Complex Range Validation","text":"<pre><code>class TemperatureModel(ValidatedModel):\n    celsius: float = field_validated(\n        is_float('Temperature must be a decimal number'),\n        min_value(-273.15, 'Temperature cannot be below absolute zero'),\n        max_value(1000, 'Temperature too high for normal measurements')\n    )\n\n    @property\n    def fahrenheit(self) -&gt; float:\n        '''\n        Converts Celsius to Fahrenheit\n\n        Returns:\n            float: Temperature in Fahrenheit\n        '''\n        return (self.celsius * 9/5) + 32\n\n    @property\n    def kelvin(self) -&gt; float:\n        '''\n        Converts Celsius to Kelvin\n\n        Returns:\n            float: Temperature in Kelvin\n        '''\n        return self.celsius + 273.15\n\n# Usage\ntemp = TemperatureModel(celsius=25.0)\nprint(f'Temperature: {temp.celsius}\u00b0C, {temp.fahrenheit}\u00b0F, {temp.kelvin}K')\n</code></pre>"},{"location":"validators/numeric/#important-notes","title":"Important Notes","text":"<ul> <li>Numeric validators return <code>True</code> if the value is <code>None</code> (for optional fields)</li> <li>Validators attempt to convert values to <code>float</code> when necessary for comparisons</li> <li>If conversion fails, the validator returns <code>False</code></li> <li>Combine numeric validators with core validators for more robust validations</li> </ul>"},{"location":"validators/string/","title":"String Validators","text":"<p>String validators provide specific functionalities for validating and verifying text formats.</p>"},{"location":"validators/string/#is_email","title":"is_email","text":"<p>Validates that the field has a valid email format.</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.string import is_email\n\nclass ContactModel(ValidatedModel):\n    email: str = field_validated(is_email())\n    backup_email: str = field_validated(is_email('Please provide a valid backup email'))\n\n# Valid usage\ncontact = ContactModel(\n    email='user@example.com',\n    backup_email='backup@domain.org'\n)\n\n# Invalid usage\ntry:\n    invalid_contact = ContactModel(email='invalid-email')\nexcept ValidationException as e:\n    print(e.validations)  # {'email': 'Invalid email format'}\n</code></pre>"},{"location":"validators/string/#parameters","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Invalid email format'</li> </ul>"},{"location":"validators/string/#is_strong_password","title":"is_strong_password","text":"<p>Validates that the password meets security criteria.</p> <pre><code>from pyvalidx.string import is_strong_password\n\nclass UserModel(ValidatedModel):\n    password: str = field_validated(is_strong_password())\n    admin_password: str = field_validated(\n        is_strong_password('Admin password must be stronger')\n    )\n\n# Valid usage\nuser = UserModel(\n    password='MySecurePass123!',\n    admin_password='AdminPass456@'\n)\n\n# Invalid usage\ntry:\n    weak_user = UserModel(password='123')\nexcept ValidationException as e:\n    print(e.validations)  # {'password': 'Password is not strong enough'}\n</code></pre>"},{"location":"validators/string/#security-criteria","title":"Security criteria:","text":"<ul> <li>Minimum length: 8 characters</li> <li>Uppercase letters: At least 1</li> <li>Lowercase letters: At least 1</li> <li>Numbers: At least 1</li> <li>Special characters: At least 1 (!@#$%^&amp;*()_+-=[]{}|;:,.&lt;&gt;?)</li> </ul>"},{"location":"validators/string/#parameters_1","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Password is not strong enough'</li> </ul>"},{"location":"validators/string/#matches_regex","title":"matches_regex","text":"<p>Validates that the field matches a regular expression pattern.</p> <pre><code>from pyvalidx.string import matches_regex\n\nclass ProductModel(ValidatedModel):\n    sku: str = field_validated(\n        matches_regex(r'^[A-Z]{3}-\\d{4}$', 'SKU must follow format ABC-1234')\n    )\n    license_plate: str = field_validated(\n        matches_regex(r'^[A-Z]{3}\\d{3}$')\n    )\n\n# Valid usage\nproduct = ProductModel(\n    sku='ABC-1234',\n    license_plate='ABC123'\n)\n</code></pre>"},{"location":"validators/string/#parameters_2","title":"Parameters","text":"<ul> <li><code>pattern</code> (str): Regular expression to match</li> <li><code>message</code> (str, optional): Custom error message. Default: 'Invalid format'</li> </ul>"},{"location":"validators/string/#no_whitespace","title":"no_whitespace","text":"<p>Validates that the field does not contain whitespace.</p> <pre><code>from pyvalidx.string import no_whitespace\n\nclass UserModel(ValidatedModel):\n    username: str = field_validated(no_whitespace())\n    api_key: str = field_validated(no_whitespace('API key cannot contain spaces'))\n\n# Valid usage\nuser = UserModel(\n    username='johndoe',\n    api_key='abc123def456'\n)\n\n# Invalid usage\ntry:\n    invalid_user = UserModel(username='john doe')\nexcept ValidationException as e:\n    print(e.validations)  # {'username': 'Must not contain spaces'}\n</code></pre>"},{"location":"validators/string/#parameters_3","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Must not contain spaces'</li> </ul>"},{"location":"validators/string/#is_phone","title":"is_phone","text":"<p>Validates that the field is a valid phone number (Colombian format).</p> <pre><code>from pyvalidx.string import is_phone\n\nclass ContactModel(ValidatedModel):\n    mobile: str = field_validated(is_phone())\n    landline: str = field_validated(is_phone('Invalid landline format'))\n\n# Valid usage\ncontact = ContactModel(\n    mobile='3001234567',\n    landline='6012345678'\n)\n\n# Invalid usage\ntry:\n    invalid_contact = ContactModel(mobile='123')\nexcept ValidationException as e:\n    print(e.validations)  # {'mobile': 'Invalid phone format'}\n</code></pre>"},{"location":"validators/string/#supported-formats","title":"Supported formats:","text":"<ul> <li>Mobile: <code>3XXXXXXXXX</code> (10 digits starting with 3)</li> <li>Landline: <code>[1-8]XXXXXXX</code> or <code>[1-8]XXXXXXXX</code> (7-8 digits)</li> <li>International: <code>+573XXXXXXXXX</code> for mobile</li> </ul>"},{"location":"validators/string/#parameters_4","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Invalid phone format'</li> </ul>"},{"location":"validators/string/#has_no_common_password","title":"has_no_common_password","text":"<p>Validates that the password is not in a list of common passwords.</p> <pre><code>from pyvalidx.string import has_no_common_password\n\n# List of common passwords\nCOMMON_PASSWORDS = {\n    '123456', 'password', '12345678', 'qwerty',\n    '123456789', '12345', '1234', '111111'\n}\n\nclass SecureUserModel(ValidatedModel):\n    password: str = field_validated(\n        has_no_common_password(COMMON_PASSWORDS)\n    )\n    backup_password: str = field_validated(\n        has_no_common_password(\n            COMMON_PASSWORDS,\n            'Backup password is too common'\n        )\n    )\n\n# Valid usage\nuser = SecureUserModel(\n    password='MyUniquePass123!',\n    backup_password='AnotherSecurePass456@'\n)\n\n# Invalid usage\ntry:\n    weak_user = SecureUserModel(password='123456')\nexcept ValidationException as e:\n    print(e.validations)  # {'password': 'Password is too common'}\n</code></pre>"},{"location":"validators/string/#parameters_5","title":"Parameters","text":"<ul> <li><code>dictionary</code> (Union[List[str], Set[str]]): List or set of forbidden passwords</li> <li><code>message</code> (str, optional): Custom error message. Default: 'Password is too common'</li> </ul>"},{"location":"validators/string/#complete-example-user-registration","title":"Complete Example: User Registration","text":"<pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required, min_length, same_as\nfrom pyvalidx.string import is_email, is_strong_password, no_whitespace\n\nCOMMON_PASSWORDS = {'123456', 'password', 'qwerty'}\n\nclass UserRegistrationModel(ValidatedModel):\n    username: str = field_validated(\n        is_required('Username is required'),\n        min_length(3, 'Username must be at least 3 characters'),\n        no_whitespace('Username cannot contain spaces')\n    )\n\n    email: str = field_validated(\n        is_required('Email is required'),\n        is_email('Please provide a valid email address')\n    )\n\n    password: str = field_validated(\n        is_required('Password is required'),\n        is_strong_password('Password must be strong'),\n        has_no_common_password(COMMON_PASSWORDS, 'Password is too common')\n    )\n\n    confirm_password: str = field_validated(\n        is_required('Password confirmation is required'),\n        same_as('password', 'Passwords must match')\n    )\n\n# Usage\nregistration = UserRegistrationModel(\n    username='johndoe',\n    email='john@example.com',\n    password='MySecurePass123!',\n    confirm_password='MySecurePass123!'\n)\n</code></pre>"},{"location":"validators/string/#advanced-string-validation","title":"Advanced String Validation","text":"<pre><code>from pyvalidx.string import matches_regex, no_whitespace\nfrom pyvalidx.core import min_length, max_length\n\nclass ProductCodeModel(ValidatedModel):\n    # Product code: 3 letters + hyphen + 4 numbers\n    product_code: str = field_validated(\n        is_required('Product code is required'),\n        matches_regex(\n            r'^[A-Z]{3}-\\d{4}$',\n            'Product code must follow format ABC-1234'\n        )\n    )\n\n    # Internal reference: no spaces, 6-12 characters\n    internal_ref: str = field_validated(\n        is_required('Internal reference is required'),\n        min_length(6, 'Reference too short'),\n        max_length(12, 'Reference too long'),\n        no_whitespace('Reference cannot contain spaces')\n    )\n\n# Usage\nproduct = ProductCodeModel(\n    product_code='ABC-1234',\n    internal_ref='REF123456'\n)\n</code></pre>"},{"location":"validators/types/","title":"Type Validators","text":"<p>Type validators provide functionalities for validating specific data types and values within predefined sets.</p>"},{"location":"validators/types/#is_dict","title":"is_dict","text":"<p>Validates that the field is a dictionary.</p> <pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.types import is_dict\n\nclass ConfigModel(ValidatedModel):\n    settings: dict = field_validated(is_dict())\n    metadata: dict = field_validated(is_dict('Metadata must be a dictionary'))\n\n# Valid usage\nconfig = ConfigModel(\n    settings={'debug': True, 'port': 8080},\n    metadata={'version': '1.0', 'author': 'John Doe'}\n)\n\n# Invalid usage\ntry:\n    invalid_config = ConfigModel(settings='not a dict')\nexcept ValidationException as e:\n    print(e.validations)  # {'settings': 'Must be a dictionary'}\n</code></pre>"},{"location":"validators/types/#parameters","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Must be a dictionary'</li> </ul>"},{"location":"validators/types/#is_list","title":"is_list","text":"<p>Validates that the field is a list.</p> <pre><code>from pyvalidx.types import is_list\n\nclass PlaylistModel(ValidatedModel):\n    songs: list = field_validated(is_list())\n    genres: list = field_validated(is_list('Genres must be a list'))\n\n# Valid usage\nplaylist = PlaylistModel(\n    songs=['Song 1', 'Song 2', 'Song 3'],\n    genres=['Rock', 'Pop', 'Jazz']\n)\n\n# Invalid usage\ntry:\n    invalid_playlist = PlaylistModel(songs='not a list')\nexcept ValidationException as e:\n    print(e.validations)  # {'songs': 'Must be a list'}\n</code></pre>"},{"location":"validators/types/#parameters_1","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Must be a list'</li> </ul>"},{"location":"validators/types/#is_boolean","title":"is_boolean","text":"<p>Validates that the field is a boolean.</p> <pre><code>from pyvalidx.types import is_boolean\n\nclass SettingsModel(ValidatedModel):\n    enabled: bool = field_validated(is_boolean())\n    debug_mode: bool = field_validated(is_boolean('Debug mode must be true or false'))\n\n# Valid usage\nsettings = SettingsModel(\n    enabled=True,\n    debug_mode=False\n)\n\n# Invalid usage\ntry:\n    invalid_settings = SettingsModel(enabled='yes')\nexcept ValidationException as e:\n    print(e.validations)  # {'enabled': 'Must be a boolean'}\n</code></pre>"},{"location":"validators/types/#parameters_2","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Must be a boolean'</li> </ul>"},{"location":"validators/types/#is_integer","title":"is_integer","text":"<p>Validates that the field is an integer.</p> <pre><code>from pyvalidx.types import is_integer\n\nclass CounterModel(ValidatedModel):\n    count: int = field_validated(is_integer())\n    max_items: int = field_validated(is_integer('Max items must be an integer'))\n\n# Valid usage\ncounter = CounterModel(\n    count=42,\n    max_items=100\n)\n\n# Invalid usage\ntry:\n    invalid_counter = CounterModel(count='not a number')\nexcept ValidationException as e:\n    print(e.validations)  # {'count': 'Must be an integer'}\n</code></pre>"},{"location":"validators/types/#parameters_3","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Must be an integer'</li> </ul>"},{"location":"validators/types/#is_float","title":"is_float","text":"<p>Validates that the field is a float.</p> <pre><code>from pyvalidx.types import is_float\n\nclass MeasurementModel(ValidatedModel):\n    temperature: float = field_validated(is_float())\n    pressure: float = field_validated(is_float('Pressure must be a decimal number'))\n\n# Valid usage\nmeasurement = MeasurementModel(\n    temperature=23.5,\n    pressure=1013.25\n)\n\n# Invalid usage\ntry:\n    invalid_measurement = MeasurementModel(temperature='hot')\nexcept ValidationException as e:\n    print(e.validations)  # {'temperature': 'Must be a float'}\n</code></pre>"},{"location":"validators/types/#parameters_4","title":"Parameters","text":"<ul> <li><code>message</code> (str, optional): Custom error message. Default: 'Must be a float'</li> </ul>"},{"location":"validators/types/#is_in","title":"is_in","text":"<p>Validates that the field value is within a predefined set of valid values.</p> <pre><code>from pyvalidx.types import is_in\n\nclass UserModel(ValidatedModel):\n    role: str = field_validated(is_in(['admin', 'user', 'guest']))\n    status: str = field_validated(\n        is_in(['active', 'inactive', 'pending'], 'Invalid user status')\n    )\n\n# Valid usage\nuser = UserModel(\n    role='admin',\n    status='active'\n)\n\n# Invalid usage\ntry:\n    invalid_user = UserModel(role='invalid_role')\nexcept ValidationException as e:\n    print(e.validations)  # {'role': 'Must be one of: ['admin', 'user', 'guest']'}\n</code></pre>"},{"location":"validators/types/#parameters_5","title":"Parameters","text":"<ul> <li><code>choices</code> (Union[List[Any], Set[Any]]): List or set of valid values</li> <li><code>message</code> (str, optional): Custom error message</li> </ul>"},{"location":"validators/types/#complete-example-configuration-system","title":"Complete Example: Configuration System","text":"<pre><code>from pyvalidx import ValidatedModel, field_validated\nfrom pyvalidx.core import is_required\nfrom pyvalidx.types import is_dict, is_list, is_boolean, is_in\nfrom pyvalidx.numeric import is_positive, min_value, max_value\n\nclass ApplicationConfigModel(ValidatedModel):\n    # Basic configuration\n    app_name: str = field_validated(is_required('Application name is required'))\n\n    # Environment validation\n    environment: str = field_validated(\n        is_required('Environment is required'),\n        is_in(['development', 'staging', 'production'], 'Invalid environment')\n    )\n\n    # Feature flags\n    debug_mode: bool = field_validated(\n        is_required('Debug mode setting is required'),\n        is_boolean('Debug mode must be true or false')\n    )\n\n    # Database configuration\n    database_config: dict = field_validated(\n        is_required('Database configuration is required'),\n        is_dict('Database config must be a dictionary')\n    )\n\n    # Allowed hosts\n    allowed_hosts: list = field_validated(\n        is_required('Allowed hosts are required'),\n        is_list('Allowed hosts must be a list')\n    )\n\n    # Port configuration\n    port: int = field_validated(\n        is_required('Port is required'),\n        is_positive('Port must be positive'),\n        min_value(1024, 'Port must be at least 1024'),\n        max_value(65535, 'Port must be at most 65535')\n    )\n\n# Valid usage\nconfig = ApplicationConfigModel(\n    app_name='MyWebApp',\n    environment='production',\n    debug_mode=False,\n    database_config={\n        'host': 'localhost',\n        'port': 5432,\n        'name': 'myapp_db'\n    },\n    allowed_hosts=['example.com', 'www.example.com'],\n    port=8080\n)\n</code></pre>"},{"location":"validators/types/#example-json-data-validation","title":"Example: JSON Data Validation","text":"<pre><code>from pyvalidx.types import is_dict, is_list\nfrom pyvalidx.string import is_email\n\nclass ApiRequestModel(ValidatedModel):\n    user_data: dict = field_validated(\n        is_required('User data is required'),\n        is_dict('User data must be a valid JSON object')\n    )\n\n    tags: list = field_validated(\n        is_list('Tags must be an array')\n    )\n\n    action: str = field_validated(\n        is_required('Action is required'),\n        is_in(['create', 'update', 'delete'], 'Invalid action type')\n    )\n\n# Valid usage\napi_request = ApiRequestModel(\n    user_data={\n        'name': 'John Doe',\n        'email': 'john@example.com',\n        'age': 30\n    },\n    tags=['important', 'user', 'profile'],\n    action='create'\n)\n\n# Invalid usage\ntry:\n    invalid_request = ApiRequestModel(\n        user_data='not a dict',\n        tags='not a list',\n        action='invalid_action'\n    )\nexcept ValidationException as e:\n    print(e.validations)\n    # Multiple validation errors will be shown\n</code></pre>"},{"location":"validators/types/#example-game-configuration","title":"Example: Game Configuration","text":"<pre><code>from pyvalidx.types import is_in, is_boolean, is_integer\n\nclass GameSettingsModel(ValidatedModel):\n    difficulty: str = field_validated(\n        is_required('Difficulty is required'),\n        is_in(['easy', 'medium', 'hard', 'expert'], 'Invalid difficulty level')\n    )\n\n    sound_enabled: bool = field_validated(\n        is_boolean('Sound setting must be true or false')\n    )\n\n    max_players: int = field_validated(\n        is_required('Max players is required'),\n        is_integer('Max players must be a number'),\n        is_in([2, 4, 6, 8], 'Max players must be 2, 4, 6, or 8')\n    )\n\n    game_modes: list = field_validated(\n        is_required('Game modes are required'),\n        is_list('Game modes must be a list')\n    )\n\n# Usage\ngame_settings = GameSettingsModel(\n    difficulty='medium',\n    sound_enabled=True,\n    max_players=4,\n    game_modes=['classic', 'tournament', 'practice']\n)\n</code></pre>"},{"location":"validators/types/#important-notes","title":"Important Notes","text":"<ul> <li>Type validators return <code>True</code> if the value is <code>None</code> (for optional fields)</li> <li><code>is_in</code> validator performs case-sensitive comparison</li> <li>For <code>is_in</code>, you can use both lists and sets for better performance with large choice sets</li> <li>Type validators can be combined with other validators for comprehensive validation</li> <li>When using <code>is_in</code> with numbers, ensure the choices match the expected data type</li> </ul>"}]}